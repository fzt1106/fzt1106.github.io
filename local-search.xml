<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>第 1 章 机器学习与深度学习的基本概念</title>
    <link href="/2024/03/07/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%9D%8E%E5%AE%8F%E6%AF%85%E8%80%81%E5%B8%88-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%AF%BE%E7%A8%8B/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/%E7%AC%AC1%E7%AB%A0%20%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"/>
    <url>/2024/03/07/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%9D%8E%E5%AE%8F%E6%AF%85%E8%80%81%E5%B8%88-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%AF%BE%E7%A8%8B/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/%E7%AC%AC1%E7%AB%A0%20%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</url>
    
    <content type="html"><![CDATA[<h1 id="第-1-章-机器学习与深度学习的基本概念"><a href="#第-1-章-机器学习与深度学习的基本概念" class="headerlink" title="第 1 章 机器学习与深度学习的基本概念"></a>第 1 章 机器学习与深度学习的基本概念</h1><h2 id="1-1-机器学习任务"><a href="#1-1-机器学习任务" class="headerlink" title="1.1 机器学习任务"></a>1.1 机器学习任务</h2><p>Machine Learning &#x3D; <strong>Looking for Function</strong></p><ul><li><code>Regression (回归)</code>：输出一个数值</li><li><code>Classification (分类)</code>：给出多种类别，函数输出正确的类别</li><li><code>Structured Learning (创造)</code>：生成图片、文档等结构化东西</li></ul><h2 id="1-2-如何定义函数"><a href="#1-2-如何定义函数" class="headerlink" title="1.2 如何定义函数"></a>1.2 如何定义函数</h2><h3 id="步骤1：-猜测函数"><a href="#步骤1：-猜测函数" class="headerlink" title="步骤1： 猜测函数"></a>步骤1： 猜测函数</h3><p>函数也称为<code>Model (模型)</code>, Model 的猜测基于 <code>domain knowledge (领域知识)</code>.</p><p>Model: $y&#x3D;b+w x_1$, 其中:</p><ul><li>$x_1$称为 <code>feture (特征值)</code>.</li><li>$w,b$ 为未知参数, $w$ 称为 <code>weight (权重)</code>, $b$ 称为 <code>bias (偏置)</code>.</li></ul><h3 id="步骤2-定义Loss"><a href="#步骤2-定义Loss" class="headerlink" title="步骤2: 定义Loss"></a>步骤2: 定义Loss</h3><p><code>Loss</code> 是一个函数 $L(b,w)$, 其作用是判断一组未知参数的值的好坏.<br>$$<br>Loss:L(b,w)&#x3D;\frac{1}{N}\sum_n e_n \<br>$$<br>其中 $e$ 是真实值与损失值的误差:</p><ul><li><code>MAE</code>: L is mean absolute error $e&#x3D;|y-\widehat{y}|$</li><li><code>MSE</code>: L is mean square error $e&#x3D;(y-\widehat{y})^2$​</li></ul><p>根据不同参数 $b,w$ 计算出的 $Loss$ 值可以画成直观的 <code>Error Surface (损失曲面)</code>.</p><h3 id="步骤3-优化"><a href="#步骤3-优化" class="headerlink" title="步骤3: 优化"></a>步骤3: 优化</h3><p>为了寻找 $w^*,b^*&#x3D; \arg \min_{w,b} {L}$​, 可以使用 <strong>Gradient Descent (梯度下降)</strong> 法: 搜索出来一个能够让函数的值尽可能小的位置.</p><blockquote><p>以上述Model为例, Gradient Descent 的具体过程如下:</p><ol><li><p>随机寻找一组初始参数 $b^0,w^0$.</p></li><li><p>分别求出 $L(b,w)$ 对 $b,w$ 的导数, 即:<br>$$<br>\frac{\partial{L}}{\partial{b}}|<em>{w&#x3D;w^0,b&#x3D;b^0}\<br>\frac{\partial{L}}{\partial{w}}|</em>{w&#x3D;w^0,b&#x3D;b^0}<br>$$</p></li><li><p>根据单调性, 对 $b,w$ 的值进行一定的调整, 使 $L$ 的值减小<br>$$<br>\begin{array}{ll}<br>b^0-\eta\frac{\partial{L}}{\partial{b}}|<em>{w&#x3D;w^0,b&#x3D;b^0} &amp; \to b^1 \<br>w^0-\eta\frac{\partial{L}}{\partial{w}}|</em>{w&#x3D;w^0,b&#x3D;b^0} &amp; \to w^1<br>\end{array}<br>$$<br>其中 $\eta$ 为 <code>learning rate (学习率)</code></p></li><li><p>重复 2, 3 步, 直到达到满意结果为止.</p></li></ol></blockquote><p>Gradient Descent的缺点是<strong>不保证找到全局最小值, 而是趋于局部最小值</strong>.</p><p>进一步, 可以根据预测结果, 使用多个 feature 来优化模型:<br>$$<br>y&#x3D;b+\sum_j w_jx_j<br>$$</p><h2 id="1-3-New-Model"><a href="#1-3-New-Model" class="headerlink" title="1.3 New Model"></a>1.3 New Model</h2><p>上述例子为 <code>linear modeal (线性模型)</code>, 但是 <strong>linear modeal 有很大的局限性, 有些曲线无法用单一的 linear modeal 来表示</strong>. 更多情况下, 需要<strong>多段 S 型曲线</strong>来表示.<br>$$<br>\text{All Piecewise Linear Curves}&#x3D; \text{Constant} + \text{Sum of a set of S}<br>$$<br>越复杂的 Piecewise Linear Curves 需要越多的 S 来逼近.</p><p>其中, S 型曲线可以用 <code>sigmoid function</code> 来表示:<br>$$<br>\begin{array}{l}<br>y &amp;&#x3D;c<em>\frac{1}{1+e^{-(b+wx_1)}}\<br>  &amp;&#x3D;c</em>sigmoid(b+wx_1)<br>\end{array}<br>$$</p><div style="text-align: center;"><img src="https://fzttypora.oss-cn-beijing.aliyuncs.com/typora_images/image-20240303100355796.png" alt="image-20240303100355796" style="zoom:50%;" /></div><p>对于改变不同参数的值, 曲线的变化如下:</p><div style="text-align: center;"><img src="https://fzttypora.oss-cn-beijing.aliyuncs.com/typora_images/image-20240303100201215.png" alt="image-20240303100201215" style="zoom: 50%;" /></div><p>于是, 可以得到更加复杂准确的 Model:<br>$$<br>\begin{array}{l}<br>y &#x3D; b+wx_1 &amp; \to<br>y&#x3D; b+\sum_i{c_i<em>sigmoid(b_i+w_ix_1)}\<br>y &#x3D; b+\sum_j{w_jx_j} &amp; \to<br>y &#x3D; b+\sum_i{c_i</em>sigmoid(b_i+\sum_j{w_{ij}x_j})}<br>\end{array}<br>$$<br>接下来, 对 $sigmoid$ 中的 $b_i+\sum_j{w_{ij}{x_j}}$ 进行简化:<br>$$<br>\begin{array}{ll}<br>r_1 &amp; &#x3D;b_1+w_{11}x_1+w_{12}x_2+w_{13}x_3\<br>r_2 &amp; &#x3D;b_2+w_{21}x_1+w_{22}x_2+w_{23}x_3\<br>r_3 &amp; &#x3D;b_3+w_{31}x_1+w_{32}x_2+w_{33}x_3\<br>\end{array}<br>$$</p><h1 id="begin-bmatrix-r-1-r-2-r-3-end-bmatrix"><a href="#begin-bmatrix-r-1-r-2-r-3-end-bmatrix" class="headerlink" title="$$\begin{bmatrix}r_1\r_2\r_3\end{bmatrix}"></a>$$<br>\begin{bmatrix}<br>r_1\<br>r_2\<br>r_3<br>\end{bmatrix}</h1><p>\begin{bmatrix}<br>w_{11} &amp; w_{12} &amp; w_{13}\<br>w_{21} &amp; w_{22} &amp; w_{23}\<br>w_{31} &amp; w_{32} &amp; w_{33}<br>\end{bmatrix}<br>*<br>\begin{bmatrix}<br>x_1\<br>x_2\<br>x_3<br>\end{bmatrix}<br>$$</p><p>$$<br>r&#x3D;b+wx<br>$$</p><p>可见, 上述公式可以简化为我们最初的样子$r&#x3D;b+wx$</p><h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><p>优化的过程同样是 Gradient Descent, 式子的形式也相同, 只不过参数增加了.</p><p>同时, 可以做如下优化:</p><div style="text-align: center;">    <img src="https://fzttypora.oss-cn-beijing.aliyuncs.com/typora_images/image-20240303093126998.png" alt="image-20240303093126998" style="zoom: 33%;" /></div><p>即将训练数据集划分为多个 <code>batch</code>, 每一批来进行 Gradient Descent, 完成所有 <code>update</code> 称为一次 <code>epoch</code>. 因此 <strong>1 epoch &#x3D; see all the batches once</strong>.</p><h3 id="Activation-function"><a href="#Activation-function" class="headerlink" title="Activation function"></a>Activation function</h3><p>上述 <code>sigmoid</code> 称为 <code>activation function (激活函数)</code>, 除了 sigmoid, 还有 <code>ReLU</code>. <del>(其实就是用两个分段曲线拼成一个 S 型曲线)</del></p><div style="text-align: center;"><img src="https://fzttypora.oss-cn-beijing.aliyuncs.com/typora_images/image-20240303094725966.png" alt="image-20240303094725966" style="zoom:33%;" /></div><h3 id="multiple-hidden-layers"><a href="#multiple-hidden-layers" class="headerlink" title="multiple hidden layers"></a>multiple hidden layers</h3><p>同时, 可以<strong>增加 activation function</strong> 的运算次数, 即增加多个<strong>隐藏层</strong>.</p><div style="text-align: center;"><img src="https://fzttypora.oss-cn-beijing.aliyuncs.com/typora_images/image-20240303095234858.png" alt="image-20240303095234858" style="zoom: 33%;" /></div><p>其中每个 <code>sigmoid</code> 称为 <code>Neuron</code> , 多层 hidden layers 就形成 <code>Neural Network</code>, 层数不断增加, 就形成了 <code>deep learning</code>, <strong>Deep &#x3D; Many hidden layers</strong>.</p>]]></content>
    
    
    <categories>
      
      <category>机器学习</category>
      
      <category>李宏毅老师机器学习课程</category>
      
      <category>课程笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>机器学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>作业 1 COVID-19 Cases Prediction</title>
    <link href="/2024/03/07/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%9D%8E%E5%AE%8F%E6%AF%85%E8%80%81%E5%B8%88-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%AF%BE%E7%A8%8B/%E4%BD%9C%E4%B8%9A/%E4%BD%9C%E4%B8%9A%201%20COVID-19%20Cases%20Prediction/"/>
    <url>/2024/03/07/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%9D%8E%E5%AE%8F%E6%AF%85%E8%80%81%E5%B8%88-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%AF%BE%E7%A8%8B/%E4%BD%9C%E4%B8%9A/%E4%BD%9C%E4%B8%9A%201%20COVID-19%20Cases%20Prediction/</url>
    
    <content type="html"><![CDATA[<h1 id="作业-1-COVID-19-Cases-Prediction"><a href="#作业-1-COVID-19-Cases-Prediction" class="headerlink" title="作业 1 COVID-19 Cases Prediction"></a>作业 1 COVID-19 Cases Prediction</h1><h2 id="Objectives"><a href="#Objectives" class="headerlink" title="Objectives"></a>Objectives</h2>]]></content>
    
    
    <categories>
      
      <category>机器学习</category>
      
      <category>李宏毅老师机器学习课程</category>
      
      <category>课程作业</category>
      
    </categories>
    
    
    <tags>
      
      <tag>机器学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第 1 章 操作系统引论</title>
    <link href="/2024/03/07/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/%E7%AC%AC%201%20%E7%AB%A0%20%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%BC%95%E8%AE%BA/"/>
    <url>/2024/03/07/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/%E7%AC%AC%201%20%E7%AB%A0%20%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%BC%95%E8%AE%BA/</url>
    
    <content type="html"><![CDATA[<h1 id="第-1-章-操作系统引论"><a href="#第-1-章-操作系统引论" class="headerlink" title="第 1 章 操作系统引论"></a>第 1 章 操作系统引论</h1><h2 id="1-1-操作系统的目标和作用"><a href="#1-1-操作系统的目标和作用" class="headerlink" title="1.1 操作系统的目标和作用"></a>1.1 操作系统的目标和作用</h2><h3 id="1-1-1-操作系统的目标"><a href="#1-1-1-操作系统的目标" class="headerlink" title="1.1.1 操作系统的目标"></a>1.1.1 操作系统的目标</h3><ol><li><strong>方便性</strong>: 针对用户-OS层考虑</li><li><strong>有效性</strong>: 针对OS-硬件层考虑, 提高系统的<strong>资源利用率</strong>和<strong>吞吐量</strong></li><li>可扩展性</li><li>开发性</li></ol><blockquote><p><strong>方便性和有效性</strong>是设计OS时最重要的两个目标.</p></blockquote><h3 id="1-2-1-操作系统的作用"><a href="#1-2-1-操作系统的作用" class="headerlink" title="1.2.1 操作系统的作用"></a>1.2.1 操作系统的作用</h3><ol><li>OS 是<strong>用户与计算机硬件系统之间的接口</strong>: 用户可以通过<strong>命令方式, 系统调用, 图像-窗口</strong>方式来使用操作系统.</li></ol><div style="text-align: center;"><img src="https://fzttypora.oss-cn-beijing.aliyuncs.com/typora_images/image-20240303194102777.png" alt="OS 作为接口的示意图" /></div><ol start="2"><li><p>OS 是<strong>计算机系统资源的管理者</strong>: OS 能有效的管理<strong>硬件资源: 处理机, 存储器, I&#x2F;O 设备</strong>, 以及<strong>软件资源: 文件(数据和程序)</strong>.</p></li><li><p>OS 实现了<strong>对计算机资源的抽象</strong>: 如 I&#x2F;O 设备管理软件, 可以<u>向上将 I&#x2F;O 设备抽象为一组数据结构和操作命令, 提供了一组抽象的 I&#x2F;O 设备, 隐藏了 I&#x2F;O 设备的具体细节</u>. 将覆盖了上述软件的及其称为<strong>扩充机器或虚机器</strong>, 它向用户提供一个<u>对硬件操作的抽象模型</u>.</p></li></ol><h3 id="1-1-3-推动操作系统发展的主要动力"><a href="#1-1-3-推动操作系统发展的主要动力" class="headerlink" title="1.1.3 推动操作系统发展的主要动力"></a>1.1.3 推动操作系统发展的主要动力</h3><ol><li>方便用户</li><li>提高计算机系统资源利用率</li><li>器件的更新换代</li><li>计算机体系结构的发展</li><li>新的应用需求</li></ol><h2 id="1-2-操作系统的发展过程"><a href="#1-2-操作系统的发展过程" class="headerlink" title="1.2 操作系统的发展过程"></a>1.2 操作系统的发展过程</h2><h3 id="1-2-1-未配置操作系统的计算机系统"><a href="#1-2-1-未配置操作系统的计算机系统" class="headerlink" title="1.2.1 未配置操作系统的计算机系统"></a>1.2.1 未配置操作系统的计算机系统</h3><h4 id="1-人工操作方式"><a href="#1-人工操作方式" class="headerlink" title="1. 人工操作方式"></a>1. 人工操作方式</h4><p>人机矛盾: 人工操作方式严重降低了计算机资源的利用率</p><ul><li>用户独占全机.</li><li>CPU 等待人工操作, CPU 与 I&#x2F;O 设备之间速度不匹配, CPU大部分时间处于空闲状态</li></ul><h4 id="2-脱机输入-输出方式"><a href="#2-脱机输入-输出方式" class="headerlink" title="2. 脱机输入&#x2F;输出方式"></a>2. 脱机输入&#x2F;输出方式</h4><ul><li><strong>脱机输入输出方式</strong>: 输入输出由<strong>外围机</strong>控制</li><li><strong>联机输入输出方式</strong>: 输入输出由<strong>主机</strong>直接控制</li></ul><div style="text-align: center;"><img src="https://fzttypora.oss-cn-beijing.aliyuncs.com/typora_images/image-20240303194325273.png" alt="脱机输入输出方式" style="zoom: 67%;" /></div><p>脱机输入输出方式的优点:</p><ul><li>减少了 CPU 的空闲时间, 输入输出操作可以与 CPU 并行进行.</li><li>提高了 I&#x2F;O 速度, CPU 直接从高速的磁带上将数据输入输出</li></ul><h3 id="1-2-2-单道批处理系统"><a href="#1-2-2-单道批处理系统" class="headerlink" title="1.2.2 单道批处理系统"></a>1.2.2 单道批处理系统</h3><h4 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h4><p>提高资源利用率和系统吞吐量</p><h4 id="关键"><a href="#关键" class="headerlink" title="关键"></a>关键</h4><p>为了实现<u>系统的连续运行</u>, 实现对作业的连续处理, 单道批处理系统将一批作业以脱机的方式输入到磁带上, 在<strong>监督程序</strong>的管理下, 将作业一个一个连续的处理.</p><div style="text-align: center;"><img src="https://fzttypora.oss-cn-beijing.aliyuncs.com/typora_images/image-20240303200424680.png" alt="单道批处理系统的处理流程" style="zoom:50%;" /></div><p>但是, 单道批处理系统最主要的缺点是: <strong>资源利用率和系统吞吐量低</strong>. 因为<u>内存中只有一道程序运行</u>, 当该程序发出 I&#x2F;O 请求后, 高速的 CPU 必须停止运行等待低速的 I&#x2F;O 设备.</p><p>如下图, 在 $t_2 \sim t_3, t_6 \sim t_7$ 时间段 CPU 处于空闲状态.</p><div style="text-align: center;"><img src="https://fzttypora.oss-cn-beijing.aliyuncs.com/typora_images/image-20240303200826694.png" alt="单道程序的运行情况" style="zoom:50%;" /></div><h3 id="1-2-3-多道批处理系统"><a href="#1-2-3-多道批处理系统" class="headerlink" title="1.2.3 多道批处理系统"></a>1.2.3 多道批处理系统</h3><h4 id="目的-1"><a href="#目的-1" class="headerlink" title="目的"></a>目的</h4><p>提高资源利用率和系统吞吐量</p><h4 id="关键-1"><a href="#关键-1" class="headerlink" title="关键"></a>关键</h4><p>多道批处理系统中, <u>内存中可以同时存在多道作业</u>, 这些作业共享 CPU 和系统中各种资源. 由于内存中存在多道作业, 在某作业进行 I&#x2F;O 操作时, CPU 可以运行其他作业, 使得 CPU 保持工作.</p><div style="text-align: center;"><img src="https://fzttypora.oss-cn-beijing.aliyuncs.com/typora_images/image-20240303202721219.png" alt="多道批处理系统运行情况" style="zoom:50%;" /></div><h4 id="多道批处理系统优缺点"><a href="#多道批处理系统优缺点" class="headerlink" title="多道批处理系统优缺点"></a>多道批处理系统优缺点</h4><ul><li>资源利用率高</li><li>系统吞吐量高</li><li><strong>平均周转时间长</strong></li><li><strong>不可交互</strong></li></ul><h3 id="1-2-4-分时系统"><a href="#1-2-4-分时系统" class="headerlink" title="1.2.4 分时系统"></a>1.2.4 分时系统</h3><h4 id="目的-2"><a href="#目的-2" class="headerlink" title="目的"></a>目的</h4><p>人-机交互, 共享主机</p><h4 id="分时系统的关键问题"><a href="#分时系统的关键问题" class="headerlink" title="分时系统的关键问题:"></a>分时系统的关键问题:</h4><ul><li><p>及时接受: 通过<u>分时多路复用, 缓冲区</u>实现.</p></li><li><p>及时处理:</p><ul><li><u>作业直接进入内存</u></li><li><u>采用轮转运行方式</u>: 每个作业每次只能运行一个<strong>时间片</strong></li></ul></li></ul><div style="text-align: center;"><img src="https://fzttypora.oss-cn-beijing.aliyuncs.com/typora_images/image-20240303204648738.png" alt="image-20240303204648738" style="zoom:80%;" /></div><h4 id="分时系统的特点"><a href="#分时系统的特点" class="headerlink" title="分时系统的特点"></a>分时系统的特点</h4><ul><li>多路性</li><li>独立性</li><li><strong>及时性</strong></li><li><strong>交互性</strong></li></ul><h3 id="1-2-5-实时系统"><a href="#1-2-5-实时系统" class="headerlink" title="1.2.5 实时系统"></a>1.2.5 实时系统</h3><h4 id="目的-3"><a href="#目的-3" class="headerlink" title="目的"></a>目的</h4><p>及时响应外部事件的请求, 在规定时间内完成对该事件的处理, 并控制所有任务协调一致运行.</p><h4 id="实时系统的任务类型"><a href="#实时系统的任务类型" class="headerlink" title="实时系统的任务类型"></a>实时系统的任务类型</h4><ul><li>周期性实时任务&#x2F;非周期性实时任务<ul><li>周期性实时任务: 周期性给计算机发出激励信号, 以周期性的控制计算机.</li><li>非周期性实时任务: 由<strong>截止时间: 开始截止时间&#x2F;完成截止时间</strong>.</li></ul></li><li>硬实时任务&#x2F;软实时任务<ul><li>硬实时任务: 严格要求满足截止时间.</li><li>软实时任务: 不严格要求满足截止时间.</li></ul></li></ul><h4 id="实时系统与分时系统的比较"><a href="#实时系统与分时系统的比较" class="headerlink" title="实时系统与分时系统的比较"></a>实时系统与分时系统的比较</h4><ul><li>多路性</li><li>独立性</li><li>及时性: 分时&lt;实时</li><li>交互性: 分时&gt;实时</li><li><strong>可靠性</strong></li></ul><h3 id="1-2-6-微机操作系统的发展"><a href="#1-2-6-微机操作系统的发展" class="headerlink" title="1.2.6 微机操作系统的发展"></a>1.2.6 微机操作系统的发展</h3><ol><li>单用户单任务操作系统: 只允许一个用户上机, 且只允许用户程序作为一个任务运行.</li><li>单用户多任务操作系统: 只允许一个用户上级, 但允许把程序分为若干个任务并行运行.</li><li>多用户多任务操作系统: 允许多个用户共享主机, 每个用户的程序可以分为若干个任务并行运行.</li></ol><h2 id="1-3-操作系统的基本特性"><a href="#1-3-操作系统的基本特性" class="headerlink" title="1.3 操作系统的基本特性"></a>1.3 操作系统的基本特性</h2><h3 id="1-3-1-并发"><a href="#1-3-1-并发" class="headerlink" title="1.3.1 并发"></a>1.3.1 并发</h3><ul><li><p>并行: 两个或多个事件在<strong>同一时刻</strong>发生.</p></li><li><p>并发: 两个或多个事件在<strong>同一时间间隔内</strong>发生. <strong>宏观上并行, 微观上交替运行</strong>.</p></li></ul><h3 id="1-3-2-共享"><a href="#1-3-2-共享" class="headerlink" title="1.3.2 共享"></a>1.3.2 共享</h3><p>资源共享 (资源复用): 系统中的资源可供内存中多个并发执行的进程共同使用.</p><ul><li><strong>互斥共享方式</strong>: 一段时间内只允许一个进程访问资源, 这种资源称为<u>临界资源 (独占资源)</u>.</li><li><strong>同时访问方式</strong>: 一段时间内运行多个进程 “同时” 访问资源. 宏观上 “同时”, 微观上 “交替”.</li></ul><blockquote><p><strong>并发和共享是多用户 (多任务) OS 的两个最基本特征.</strong></p></blockquote><h3 id="1-3-3-虚拟"><a href="#1-3-3-虚拟" class="headerlink" title="1.3.3 虚拟"></a>1.3.3 虚拟</h3><p>虚拟: 一个物理实体变为多个逻辑上的虚拟体.</p><ul><li><strong>时分复用技术</strong>: 为某一个用户提供服务的空闲时间, 转去为其他用户提供服务.</li><li><strong>空分复用技术</strong>: 单纯的空分复用技术只能提高内存利用率, 但是不能在逻辑上扩大内存. 需要用到虚拟存储技术, 其实际上是通过<u>时分复用内存</u>的方式来实现.</li></ul><h3 id="1-3-4-异步"><a href="#1-3-4-异步" class="headerlink" title="1.3.4 异步"></a>1.3.4 异步</h3><p>进程是以 “走走停停” 的方式执行, 是<strong>不可预知, 不确定</strong>的.</p><h2 id="1-4-操作系统的主要功能"><a href="#1-4-操作系统的主要功能" class="headerlink" title="1.4 操作系统的主要功能"></a>1.4 操作系统的主要功能</h2><ol><li><strong>处理机管理功能</strong></li><li><strong>存储器管理功能</strong></li><li><strong>设备管理功能</strong></li><li><strong>文件管理功能</strong></li><li><strong>提供 “用户与操作系统的接口”</strong></li><li>现代操作系统的新功能<ol><li>系统安全</li><li>网络功能和服务</li><li>支持多媒体</li></ol></li></ol><h2 id="1-5-OS-结构设计"><a href="#1-5-OS-结构设计" class="headerlink" title="1.5 OS 结构设计"></a>1.5 OS 结构设计</h2><ul><li>传统操作系统结构<ul><li>无结构操作系统</li><li>模块化结构 OS</li><li>分层结构 OS</li></ul></li><li>微内核 OS 结构</li></ul>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
      <category>操作系统课程笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
      <tag>学习笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第 3 章 Scanning</title>
    <link href="/2024/03/07/Crafting%20Interpreters/%E7%AC%AC%203%20%E7%AB%A0%20Scanning/"/>
    <url>/2024/03/07/Crafting%20Interpreters/%E7%AC%AC%203%20%E7%AB%A0%20Scanning/</url>
    
    <content type="html"><![CDATA[<h1 id="第-3-章-Scanning"><a href="#第-3-章-Scanning" class="headerlink" title="第 3 章 Scanning"></a>第 3 章 Scanning</h1><p>任何编译器的第一步都是 scanning. scanner 以一系列字符的形式接收源代码, 并将其分成一系列块, 称为 <code>tokens (语法单元)</code>.</p><h2 id="3-1-The-Interpreter-Framework-解释器框架"><a href="#3-1-The-Interpreter-Framework-解释器框架" class="headerlink" title="3.1 The Interpreter Framework (解释器框架)"></a>3.1 The Interpreter Framework (解释器框架)</h2>]]></content>
    
    
    <categories>
      
      <category>项目</category>
      
      <category>Crafting Interpreters</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Interpreter</tag>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第 2 章 The Lox Language</title>
    <link href="/2024/03/07/Crafting%20Interpreters/%E7%AC%AC%202%20%E7%AB%A0%20The%20Lox%20Language/"/>
    <url>/2024/03/07/Crafting%20Interpreters/%E7%AC%AC%202%20%E7%AB%A0%20The%20Lox%20Language/</url>
    
    <content type="html"><![CDATA[<h1 id="第-2-章-The-Lox-Language"><a href="#第-2-章-The-Lox-Language" class="headerlink" title="第 2 章 The Lox Language"></a>第 2 章 The Lox Language</h1><h2 id="2-1-Hello-Lox"><a href="#2-1-Hello-Lox" class="headerlink" title="2.1 Hello, Lox"></a>2.1 Hello, Lox</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">print <span class="hljs-string">&quot;Hello, world!&quot;</span>;<br></code></pre></td></tr></table></figure><p>lox 语言是 C 语言的家族成员之一</p><h2 id="2-2-A-High-Level-Language"><a href="#2-2-A-High-Level-Language" class="headerlink" title="2.2 A High-Level Language"></a>2.2 A High-Level Language</h2><p>与 Lox 有共同之处的三个语言:</p><ul><li>JavaScript: Lox 语法与 JavaScript 相似, 因为大多数 C 语法语言都是这样的.</li><li>Scheme: Lox 的范围界定方法上与 Scheme 相关.</li><li>Lua: 构建 C 风格的 Lox 很大程度上借鉴了 Lua 的干净, 高效的实现.</li></ul><p>明显的共同之处有以下两点:</p><h3 id="2-2-1-Dynamic-typing-动态类型"><a href="#2-2-1-Dynamic-typing-动态类型" class="headerlink" title="2.2.1 Dynamic typing (动态类型)"></a>2.2.1 Dynamic typing (动态类型)</h3><p>Lox 是动态类型的, 即变量可以存储任何类型的值, 单个变量在不同时间可以有不同的类型. 静态类型系统需要学习和实现大量工作, 跳过它会使语言更加简单实现. 动态类型将类型检查推迟到运行时, 这样可以更快启动解释器并执行代码.</p><h3 id="2-2-2-Automatic-memory-management-自动内存管理"><a href="#2-2-2-Automatic-memory-management-自动内存管理" class="headerlink" title="2.2.2 Automatic memory management (自动内存管理)"></a>2.2.2 Automatic memory management (自动内存管理)</h3><p>有两种主要的内存管理技术:</p><ul><li><strong>reference counting (引用计数)</strong></li><li><strong>tracing garbage collection (跟踪垃圾收集器)</strong></li></ul><p>现在主要使用 <strong>GC</strong>, 同时我们也需要写出自己的垃圾收集器.</p><h2 id="2-3-Date-Tyeps-数据类型"><a href="#2-3-Date-Tyeps-数据类型" class="headerlink" title="2.3 Date Tyeps (数据类型)"></a>2.3 Date Tyeps (数据类型)</h2><ul><li><code>Booleans</code>: 布尔类型</li><li><code>Numbers</code>: 双精度浮点数</li><li><code>Strings</code>: 字符串</li><li><code>Nil</code>: 相当于<code>null</code></li></ul><h2 id="2-4-Expressions-表达式"><a href="#2-4-Expressions-表达式" class="headerlink" title="2.4 Expressions (表达式)"></a>2.4 Expressions (表达式)</h2><ul><li>Arithmetic (算术运算): +, - , *, &#x2F;</li><li>Comparison and equality (比较与相等): &lt;, &lt;&#x3D;, &gt;, &gt;&#x3D;, &#x3D;&#x3D;</li><li>Logical operatiors (逻辑运算): and, or, !</li><li>Precedence and grouping (优先级与分组): 优先级形式与 C 语言相同, 同时通过 () 进行分组</li></ul><h2 id="2-5-Statement-语句"><a href="#2-5-Statement-语句" class="headerlink" title="2.5 Statement (语句)"></a>2.5 Statement (语句)</h2><p>表达式主要作用是产生一个值, 而语句的作用是产生一个效果 (修改某些状态, 输入, 输出).</p><p>表达式后面跟分号 <code>;</code> 可以将表达式提升为语句, 称为 <code>expression statement</code>. 同时, 可以将一系列语句通过 <code>&#123;&#125;</code> 打包在一个块中, 并且块也会影响作用域.</p><h2 id="3-6-Variables-变量"><a href="#3-6-Variables-变量" class="headerlink" title="3.6 Variables (变量)"></a>3.6 Variables (变量)</h2><p>可以通过 <code>var</code> 来声明一个变量, 若未进行初始化, 那么变量的值是 <code>nil</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">var breakfast = <span class="hljs-string">&quot;bagels&quot;</span>;<br>print breakfast; <span class="hljs-comment">// &quot;bagels&quot;.</span><br>breakfast = <span class="hljs-string">&quot;beignets&quot;</span>;<br>print breakfast; <span class="hljs-comment">// &quot;beignets&quot;.</span><br></code></pre></td></tr></table></figure><h2 id="3-7-Control-Flow-控制流"><a href="#3-7-Control-Flow-控制流" class="headerlink" title="3.7 Control Flow (控制流)"></a>3.7 Control Flow (控制流)</h2><ul><li><code>if</code></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (condition) &#123;<br>  print <span class="hljs-string">&quot;yes&quot;</span>;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>  print <span class="hljs-string">&quot;no&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>while</code></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c">var a = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">while</span> (a &lt; <span class="hljs-number">10</span>) &#123;<br>  print a;<br>  a = a + <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>for</code></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">for</span> (var a = <span class="hljs-number">1</span>; a &lt; <span class="hljs-number">10</span>; a = a + <span class="hljs-number">1</span>) &#123;<br>  print a;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-8-Functions-函数"><a href="#3-8-Functions-函数" class="headerlink" title="3.8 Functions (函数)"></a>3.8 Functions (函数)</h2><p>可以通过 <code>fun</code> 来声明一个函数, 并通过 <code>return</code> 返回一个值. 若无 <code>return</code> 则返回 <code>nil</code>.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C">fun <span class="hljs-title function_">returnSum</span><span class="hljs-params">(a, b)</span> &#123;<br>  <span class="hljs-keyword">return</span> a + b;<br>&#125;<br></code></pre></td></tr></table></figure><p>函数调用与 C 语言中形式一样</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">makeBreakfast(bacon, eggs, toast);<br></code></pre></td></tr></table></figure><p>注意区分 <strong>argument, parameter</strong>:</p><ul><li>argument: <strong>实际参数</strong></li><li>parameter: <strong>形式参数</strong></li></ul><h2 id="3-9-Closures-闭包"><a href="#3-9-Closures-闭包" class="headerlink" title="3.9 Closures (闭包)"></a>3.9 Closures (闭包)</h2><p>在 Lox 中, 函数是真实的值, 可以对这些值进行引用, 存储在变量中, 传递等.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c">fun <span class="hljs-title function_">addPair</span><span class="hljs-params">(a, b)</span> &#123;<br>  <span class="hljs-keyword">return</span> a + b;<br>&#125;<br><br>fun <span class="hljs-title function_">identity</span><span class="hljs-params">(a)</span> &#123;<br>  <span class="hljs-keyword">return</span> a;<br>&#125;<br><br>print <span class="hljs-title function_">identity</span><span class="hljs-params">(addPair)</span><span class="hljs-params">(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)</span>; <span class="hljs-comment">// Prints &quot;3&quot;.</span><br></code></pre></td></tr></table></figure><p>由于函数是声明语句, 可以在另一个函数中声明局部函数.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c">fun <span class="hljs-title function_">outerFunction</span><span class="hljs-params">()</span> &#123;<br>  fun <span class="hljs-title function_">localFunction</span><span class="hljs-params">()</span> &#123;<br>    print <span class="hljs-string">&quot;I&#x27;m local!&quot;</span>;<br>  &#125;<br><br>  localFunction();<br>&#125;<br></code></pre></td></tr></table></figure><p>若将局部函数, 头等函数, 块作用域组合在一起:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c">fun <span class="hljs-title function_">returnFunction</span><span class="hljs-params">()</span> &#123;<br>  var outside = <span class="hljs-string">&quot;outside&quot;</span>;<br><br>  fun <span class="hljs-title function_">inner</span><span class="hljs-params">()</span> &#123;<br>    print outside;<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> inner;<br>&#125;<br><br>var fn = returnFunction();<br>fn();<br></code></pre></td></tr></table></figure><p>在上述代码中, <code>inner()</code> 访问了在其函数体外的外部函数中声明的局部变量. 为做到这一点, <code>inner()</code> 必须保留对它使用的任何周围变量的引用, 即使在外层函数返回之后, 这些变量仍然存在. 我们把能做到这一点的函数称为 <strong>closures (闭包)</strong>.</p><h2 id="3-10-Classes-类"><a href="#3-10-Classes-类" class="headerlink" title="3.10 Classes (类)"></a>3.10 Classes (类)</h2><h3 id="3-10-1-class-and-prototypes"><a href="#3-10-1-class-and-prototypes" class="headerlink" title="3.10.1 class and prototypes"></a>3.10.1 class and prototypes</h3><p>当涉及对象时, 有两种方法: <strong>class (类), prototypes(原型)</strong></p><ul><li>class: 有两个核心概念:实例和类<ul><li>实例存储每个对象的状态, 并且有一个对实例的类的引用.</li><li>类包含方法和继承链.</li><li>要在实例上调用类, 会有一个中间层, 先查找到实例的类, 任何在其中找到方法.</li></ul></li><li>prototypes: <strong>只有对象, 没有类</strong><ul><li>每个对象都有自己的方法和状态.</li><li>对象之间可以继承.</li></ul></li></ul><p>原型在语言中更简单, 但是, 它们似乎只是通过将复杂性推给用户来实现的. 对于 Lox 来说, 将省去用户的麻烦, 直接把类包含进去.</p><h3 id="3-10-2-Lox-中的类"><a href="#3-10-2-Lox-中的类" class="headerlink" title="3.10.2 Lox 中的类"></a>3.10.2 Lox 中的类</h3><p>声明一个类及其方法:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Breakfast</span> &#123;</span><br>  cook() &#123;<br>    print <span class="hljs-string">&quot;Eggs a-fryin&#x27;!&quot;</span>;<br>  &#125;<br><br>  serve(who) &#123;<br>    print <span class="hljs-string">&quot;Enjoy your breakfast, &quot;</span> + who + <span class="hljs-string">&quot;.&quot;</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>类声明生效时, Lox 将创建一个对象, 并将其存储在以该类命名的变量中.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Store it in variables.</span><br>var someVariable = Breakfast;<br><br><span class="hljs-comment">// Pass it to functions.</span><br>someFunction(Breakfast);<br></code></pre></td></tr></table></figure><p>创建类的实例, 可以使用类似于调用函数的方法:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">var breakfast = Breakfast();<br>print breakfast; <span class="hljs-comment">// &quot;Breakfast instance&quot;.</span><br></code></pre></td></tr></table></figure><h3 id="3-10-3-Instantiation-and-initialization-实例和初始化"><a href="#3-10-3-Instantiation-and-initialization-实例和初始化" class="headerlink" title="3.10.3 Instantiation and initialization (实例和初始化)"></a>3.10.3 Instantiation and initialization (实例和初始化)</h3><p>类中不仅有方法, 还有状态. Lox 允许自由地向对象中添加状态. 若起初没有该字段, 那么对它进行赋值时会先创建.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">breakfast.meat = <span class="hljs-string">&quot;sausage&quot;</span>;<br>breakfast.bread = <span class="hljs-string">&quot;sourdough&quot;</span>;<br></code></pre></td></tr></table></figure><p>若想从方法内部访问当前对象上的字段或方法, 可以使用 <code>this</code>:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Breakfast</span> &#123;</span><br>  serve(who) &#123;<br>    print <span class="hljs-string">&quot;Enjoy your &quot;</span> + this.meat + <span class="hljs-string">&quot; and &quot;</span> +<br>        this.bread + <span class="hljs-string">&quot;, &quot;</span> + who + <span class="hljs-string">&quot;.&quot;</span>;<br>  &#125;<br><br>  <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>在对象中封装数据的目的之一是确保对象在创建时处于有效状态, 可以定义一个初始化器 <code>init()</code>, 在构造对象时会自动调用该方法.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Breakfast</span> &#123;</span><br>  init(meat, bread) &#123;<br>    this.meat = meat;<br>    this.bread = bread;<br>  &#125;<br><br>  <span class="hljs-comment">// ...</span><br>&#125;<br><br>var baconAndToast = Breakfast(<span class="hljs-string">&quot;bacon&quot;</span>, <span class="hljs-string">&quot;toast&quot;</span>);<br>baconAndToast.serve(<span class="hljs-string">&quot;Dear Reader&quot;</span>);<br><span class="hljs-comment">// &quot;Enjoy your bacon and toast, Dear Reader.&quot;</span><br></code></pre></td></tr></table></figure><h3 id="3-10-4-Inheritance-继承"><a href="#3-10-4-Inheritance-继承" class="headerlink" title="3.10.4 Inheritance (继承)"></a>3.10.4 Inheritance (继承)</h3><p>使用 <code>&lt;</code> 来实现继承:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Brunch</span> &lt;</span> Breakfast &#123;<br>  drink() &#123;<br>    print <span class="hljs-string">&quot;How about a Bloody Mary?&quot;</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Brunch 是 <strong>derived class (派生类) or subclass 子类)</strong>, Breakfast 是 <strong>base class (基类) or superclass (超类)</strong>.</p><p>父类中定义的方法都会被子类继承, <code>init()</code> 同样会被继承. 但是为了确保父类维护其状态, 又不通过调用原始的初始化方法, 可以使用 <code>super</code>.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Brunch</span> &lt;</span> Breakfast &#123;<br>  init(meat, bread, drink) &#123;<br>    super.init(meat, bread);<br>    this.drink = drink;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-11-The-Standary-Library-标准库"><a href="#3-11-The-Standary-Library-标准库" class="headerlink" title="3.11 The Standary Library (标准库)"></a>3.11 The Standary Library (标准库)</h2><p>一组直接在解释器中实现的功能集, 所有用户定义的行为都是建立在此基础上.</p>]]></content>
    
    
    <categories>
      
      <category>项目</category>
      
      <category>Crafting Interpreters</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Interpreter</tag>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第 1 章 A Map of the Territory</title>
    <link href="/2024/03/07/Crafting%20Interpreters/%E7%AC%AC%201%20%E7%AB%A0%20A%20Map%20of%20the%20Terriory/"/>
    <url>/2024/03/07/Crafting%20Interpreters/%E7%AC%AC%201%20%E7%AB%A0%20A%20Map%20of%20the%20Terriory/</url>
    
    <content type="html"><![CDATA[<h1 id="第-1-章-A-Map-of-the-Territory"><a href="#第-1-章-A-Map-of-the-Territory" class="headerlink" title="第 1 章 A Map of the Territory"></a>第 1 章 A Map of the Territory</h1><h2 id="1-1-语言各部分"><a href="#1-1-语言各部分" class="headerlink" title="1.1 语言各部分"></a>1.1 语言各部分</h2><div style="text-align center;"><img src="https://fzttypora.oss-cn-beijing.aliyuncs.com/typora_images/image-20240303114655871.png" alt="image-20240303114655871" style="zoom: 80%;" /></div><h3 id="1-1-1-Scanning-扫描-词法分析"><a href="#1-1-1-Scanning-扫描-词法分析" class="headerlink" title="1.1.1 Scanning (扫描|词法分析)"></a>1.1.1 Scanning (扫描|词法分析)</h3><p><code>Scanning (扫描) </code>等同于 <code>lexing (词法分析)</code>, <code>Scanner (or lexer)</code> 的作用是: 接受线性字符流，并将它们切分成类似于“单词”的多个小单元，这些单元称为 <code>token (词法单元) </code>.</p><p>词法单元可以是一个字符 <code>(</code>, 也可以是数字 <code>123</code>, 字符串 <code>hi</code>, 标识符 <code>cin</code></p><p>源文件中一些字符是没有意义的, 比如空格和注释. Scanner会忽略这些, 最终得到一个简单的字符单元序列.</p><p><img src="https://fzttypora.oss-cn-beijing.aliyuncs.com/typora_images/image-20240228105116906.png" alt="image-20240228105116906"></p><p><img src="https://fzttypora.oss-cn-beijing.aliyuncs.com/typora_images/image-20240228105133238.png" alt="image-20240228105133238"></p><h3 id="1-1-2-Parsing-解析-语法分析"><a href="#1-1-2-Parsing-解析-语法分析" class="headerlink" title="1.1.2 Parsing (解析|语法分析)"></a>1.1.2 Parsing (解析|语法分析)</h3><p><code>Parsing (解析) </code>即<code>语法分析</code>, <code>parser (解析器) </code>作用是：将<strong>词法单元序列转化为树形结构</strong>。因为树形结构能很好的反映语法的嵌套结构. 这些树称为 <code>parse tree, abstract syntax tree</code>. 同时，解析器的作用还包括检测 <code>syntax errors (语法错误)</code>.</p><div style="text-align: center;"><img src="https://fzttypora.oss-cn-beijing.aliyuncs.com/typora_images/image-20240228102912591.png" alt="image-20240228102912591" /></div><h3 id="1-1-3-Static-analysis-静态分析"><a href="#1-1-3-Static-analysis-静态分析" class="headerlink" title="1.1.3 Static analysis (静态分析)"></a>1.1.3 Static analysis (静态分析)</h3><p>静态分析的任务是: <code>bingding (绑定) or resolution (决议) </code>, 即对于每一个标识符，找出定义该名字的地方，并将二者联系起来。</p><p>要实现绑定，所有语义的信息都需要存储在某个地方，有以下地方可供选择：</p><ul><li>存储在语法树本身的<strong>属性</strong>字段中.（属性是节点的额外字段）</li><li>存储在外部查找表中, 称其为<strong>符号表</strong>.</li><li>将树转换为一个全新的数据结构, 更直接的表达代码的语义.</li></ul><h3 id="1-1-4-Intermediate-representations-中间码"><a href="#1-1-4-Intermediate-representations-中间码" class="headerlink" title="1.1.4 Intermediate representations (中间码)"></a>1.1.4 Intermediate representations (中间码)</h3><p>前面的内容属于 <code>front end (前端)</code>, 后续则是 <code>back end (后端)</code>, 在二者中间还有<code>middle end (中端)</code>.</p><p>前端关注源语言编写的程序, 后端则关注程序运行的整个架构. 而中端阶段, 代码被存储在 <code>Intermediate representations (中间代码)</code> 中, 这些中间代码与源文件或目的文件没有紧密的联系, 而是充当它们之间的<strong>接口</strong>.</p><h3 id="1-1-5-Optimization-优化"><a href="#1-1-5-Optimization-优化" class="headerlink" title="1.1.5 Optimization (优化)"></a>1.1.5 Optimization (优化)</h3><p><code>Optimization (优化)</code>的任务是: 在理解用户的程序后，用另一个具有相同语义但是实现效率更高的程序来代替它.</p><p>比如, <code>constant floding (常量折叠)</code>: 可以在编译过程中计算出哪些简单的表达式, 并将计算结果直接替换表达式.</p><h3 id="1-1-6-Code-generation-代码生成"><a href="#1-1-6-Code-generation-代码生成" class="headerlink" title="1.1.6 Code generation (代码生成)"></a>1.1.6 Code generation (代码生成)</h3><p>在优化用户程序之后, 需要将其转化为机器可以实际运行的代码, 即<code>Code generation (代码生成)</code>, 生成的代码通常是CPU运行的类似于汇编的原始指令.</p><p>但是, 不应该为芯片生成机器指令, 因为缺乏可移植性. 实际上, 编译器是为一个假设的, 理想化的机器编写代码, 成为<code>bytecode (字节码)</code>.</p><h3 id="1-1-7-Virtual-machine-虚拟机"><a href="#1-1-7-Virtual-machine-虚拟机" class="headerlink" title="1.1.7 Virtual machine (虚拟机)"></a>1.1.7 Virtual machine (虚拟机)</h3><p>编译器产生字节码之后, 芯片仍然不能解析这些字节码, 还需进行翻译工作, 有以下两种方法:</p><ul><li>为每个目标体系结构编写一个小型编译器, 将字节码转化为该机器的本机代码. 虽然仍然需要为每个芯片做翻译工作, 但是工作任务简单.</li><li><em>可以编写<code>VM (虚拟机)</code>, 该程序可在运行时模拟支持虚拟架构的虚拟芯片. 运行字节码比翻译成本机代码运行要慢, 但好处是简单并且具有可移植性.</em></li></ul><h3 id="1-1-8-Runtime-运行时"><a href="#1-1-8-Runtime-运行时" class="headerlink" title="1.1.8 Runtime (运行时)"></a>1.1.8 Runtime (运行时)</h3><p>有时需要我们的语言在程序运行时提供一些特殊的服务, 比如自动内存管理: 需要一个垃圾收集器去回收未使用的bit. 这些东西是在<code>Runtime (运行时)</code>进行的，这些实现运行时的代码会直接插入到生成的可执行文件中.</p><h2 id="1-2-捷径和备选路线"><a href="#1-2-捷径和备选路线" class="headerlink" title="1.2 捷径和备选路线"></a>1.2 捷径和备选路线</h2><h3 id="1-2-1-Single-pass-compilers-单遍编译器"><a href="#1-2-1-Single-pass-compilers-单遍编译器" class="headerlink" title="1.2.1 Single-pass compilers (单遍编译器)"></a>1.2.1 Single-pass compilers (单遍编译器)</h3><p>Single-pass compilers 将 parsing, analysis, and code generation 交织在一起, 使它们可以直接在 parser 中生成输出代码, 不需要其他 syntax trees.</p><p><em>但是这类 Single-pass compilers 限制了语言的设计: 没有中间数据结构来存储程序, 不会重新访问任何之前解析过的代码的部分.</em></p><h3 id="1-2-2-Tree-walk-interpreters-树遍历解释器"><a href="#1-2-2-Tree-walk-interpreters-树遍历解释器" class="headerlink" title="1.2.2 Tree-walk interpreters (树遍历解释器)"></a>1.2.2 Tree-walk interpreters (树遍历解释器)</h3><p><em>Tree-walk interpreters 将代码解析为 AST, 运行程序时, 解释器每次都会遍历语法树的一个分支和叶子, 并在计算每个节点.</em></p><h3 id="1-2-3-Transpiler-转译器"><a href="#1-2-3-Transpiler-转译器" class="headerlink" title="1.2.3 Transpiler (转译器)"></a>1.2.3 Transpiler (转译器)</h3><div class="note note-info">            <p>不理解, 待补</p>          </div><h3 id="1-2-4-Just-in-time-compilation-即时编译"><a href="#1-2-4-Just-in-time-compilation-即时编译" class="headerlink" title="1.2.4 Just-in-time compilation (即时编译)"></a>1.2.4 Just-in-time compilation (即时编译)</h3><div class="note note-info">            <p>不理解, 待补</p>          </div><h2 id="1-3-Compilers-and-Interpreters-编译器和解释器"><a href="#1-3-Compilers-and-Interpreters-编译器和解释器" class="headerlink" title="1.3 Compilers and Interpreters (编译器和解释器)"></a>1.3 Compilers and Interpreters (编译器和解释器)</h2><ul><li>Compilers: 将源语言翻译成其他语言, 但不会执行, 用户必须自己运行. 典型代表是 GCC, Clang, 它们是 C 编译器.<ul><li>较低级形式的语言: 字节码, 机器码</li><li>另一种高级语言</li></ul></li><li>Interpreters: 接受源代码并立即执行. 如 Ruby.</li></ul><div style="text-align: center;"><img src="https://fzttypora.oss-cn-beijing.aliyuncs.com/typora_images/image-20240303144709671.png" alt="image-20240303144709671" style="zoom:50%;" /></div><p>对于 CPython, 其看起来是 Interpreters, 但是其内部实现还有有一些 Compile 的工作. 大多洒脚本语言都是这种工作方式.</p>]]></content>
    
    
    <categories>
      
      <category>项目</category>
      
      <category>Crafting Interpreters</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Interpreter</tag>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Codeforces Round 930 (Div. 2)</title>
    <link href="/2024/03/07/Codeforces/2024.3.6-Codeforces%20Round%20930%20(Div.%202)/"/>
    <url>/2024/03/07/Codeforces/2024.3.6-Codeforces%20Round%20930%20(Div.%202)/</url>
    
    <content type="html"><![CDATA[<blockquote><p>[!Note]</p><p>比赛地址: <a href="https://codeforces.com/contest/1937">Dashboard - Codeforces Round 930 (Div. 2) - Codeforces</a></p><p>完成题目: A~C</p></blockquote><h1 id="Codeforces-Round-930-Div-2"><a href="#Codeforces-Round-930-Div-2" class="headerlink" title="Codeforces Round 930 (Div. 2)"></a>Codeforces Round 930 (Div. 2)</h1><h2 id="A-Shuffle-Party"><a href="#A-Shuffle-Party" class="headerlink" title="A. Shuffle Party"></a>A. Shuffle Party</h2><h3 id="Tags"><a href="#Tags" class="headerlink" title="Tags"></a>Tags</h3><ul><li>算法: 数学</li><li>难度: Easy</li></ul><h3 id="Idea"><a href="#Idea" class="headerlink" title="Idea"></a>Idea</h3><p>只用关注 1 的状态, 找到第一个以 1 的位置为最大除数的位置即可:</p><ul><li>1 的位置 P(1) &#x3D; 1 时, 它是 2 的最大除数, P(1) &#x3D; 2.</li><li>1 的位置 P(1) &#x3D; 2 时, 它是 4 的最大除数, P(1) &#x3D; 4.</li><li>1 的位置 P(1) &#x3D; 4 时, 它是 8 的最大除数, P(1) &#x3D; 8.</li><li>…..</li><li>P(1) &#x3D; 2*上一个 P(1).</li></ul><p>所以, 只用看 n 的最近的 2 次幂即为答案.</p><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">int</span> n;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br><br>    cin &gt;&gt; n;<br>    <span class="hljs-type">int</span> x = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (x &lt;= n) &#123;<br>        <span class="hljs-keyword">if</span> (x * <span class="hljs-number">2</span> &gt; n) &#123;<br>            cout &lt;&lt; x &lt;&lt; endl;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        x *= <span class="hljs-number">2</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>    cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);cout.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-type">int</span> t;<br>    cin &gt;&gt; t;<br>    <span class="hljs-keyword">while</span> (t--) &#123;<br>        <span class="hljs-built_in">solve</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="B-Binary-Path"><a href="#B-Binary-Path" class="headerlink" title="B. Binary Path"></a>B. Binary Path</h2><h3 id="Tags-1"><a href="#Tags-1" class="headerlink" title="Tags"></a>Tags</h3><ul><li>算法: 思维, 贪心</li><li>难度: Mid</li></ul><h3 id="Idea-1"><a href="#Idea-1" class="headerlink" title="Idea"></a>Idea</h3><p>由于只能向下走或向右走, 因此只能向下走 1 次.</p><p>先不考虑数量, 考虑如何寻找最优字符串: 由于只能向下走 1 次, 而且向下之后后面的结果是固定的, 因此若当前这步向下向右的效果是一样是, 向右是更优的. 考虑当前这步的下面与右面, 以下的策略可以找到最优字符串.</p><div style="text-align:center;"> <img src="https://fzttypora.oss-cn-beijing.aliyuncs.com/typora_images/image-20240306203421682.png" alt="image-20240306203421682" /> </div><p>对于寻找数量, 可以从向下的位置开始, 往前或往后逐个寻找: 条件是左下角和右上角需相同, 并且一旦不相同就不用继续寻找.</p><div style="text-align:center;"> <img src="https://fzttypora.oss-cn-beijing.aliyuncs.com/typora_images/image-20240306204126275.png" alt="image-20240306204126275" /> </div><h3 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">int</span> n;<br>string a, b;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    cin &gt;&gt; n;<br>    cin &gt;&gt; a &gt;&gt; b;<br>    <span class="hljs-type">int</span> d = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; n;i++) &#123;<br>        <span class="hljs-keyword">if</span> (i == n - <span class="hljs-number">1</span> || (a[i] == <span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; b[i] == <span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; a[i + <span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;1&#x27;</span>) || (a[i] == <span class="hljs-string">&#x27;1&#x27;</span> &amp;&amp; b[i] == <span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; a[i + <span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;1&#x27;</span>)) &#123;<br>            d = i;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>    string s = <span class="hljs-string">&quot;&quot;</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; n;i++) &#123;<br>        <span class="hljs-keyword">if</span> (i &lt; d) s += a[i];<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (i &gt; d)s += b[i];<br>        <span class="hljs-keyword">else</span> s = s + a[i] + b[i];<br>    &#125;<br>    cout &lt;&lt; s &lt;&lt; endl;<br>    <span class="hljs-type">int</span> ans = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = d - <span class="hljs-number">1</span>;i &gt;= <span class="hljs-number">0</span>;i--) &#123;<br>        <span class="hljs-keyword">if</span> (b[i] == a[i + <span class="hljs-number">1</span>])ans++;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = d + <span class="hljs-number">1</span>;i &lt; n;i++) &#123;<br>        <span class="hljs-keyword">if</span> (a[i] == b[i - <span class="hljs-number">1</span>])ans++;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">break</span>;<br>    &#125;<br>    cout &lt;&lt; ans &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>    cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);cout.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-type">int</span> t;<br>    cin &gt;&gt; t;<br>    <span class="hljs-keyword">while</span> (t--) &#123;<br>        <span class="hljs-built_in">solve</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="C-Bitwise-Operation-Wizard"><a href="#C-Bitwise-Operation-Wizard" class="headerlink" title="C. Bitwise Operation Wizard"></a>C. Bitwise Operation Wizard</h2><h3 id="Tags-2"><a href="#Tags-2" class="headerlink" title="Tags"></a>Tags</h3><ul><li>算法: 思维, 数学, 交互</li><li>难度: Mid++</li></ul><h3 id="Idea-2"><a href="#Idea-2" class="headerlink" title="Idea"></a>Idea</h3><p>首先对于 0 ~ n-1 的队列, 两个数异或的最大值肯定是二进制位全 1 的数. 观察题目限制是 3n 步, 因此可以猜测需要进行 3 轮.</p><p>每次需要拿出 4 个值, 可以想到, 肯定需要一个参照数. 于是可以试着用 n 步冒泡排序来找到<strong>最大值 idx 的位置</strong>. 该位置不仅可以用来当作参照, 而且<strong>最大值 idx 一定可以构成答案</strong>. 于是接下来的任务是寻找另一个数使其与 idx 构成答案.</p><p>因为答案的结果是二进制位全 1 的值, 因此我们可以进行 n 步将与 idx 与操作后二进制位全为 1 的数找出来.</p><p>但是这些数不一定是结果, 因为异或可能会使某个二进制位不为 1. 但是, 其中的<strong>最小值</strong>一定可以与 idx 异或后结果为答案. 于是最后一轮从上面那些数中找到最小的即可.</p><h3 id="Code-2"><a href="#Code-2" class="headerlink" title="Code"></a>Code</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">int</span> n;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    cin &gt;&gt; n;<br>    <span class="hljs-type">int</span> idx = <span class="hljs-number">0</span>, nx = <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> t = n;<br>    <span class="hljs-keyword">while</span> (--t) &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;? &quot;</span> &lt;&lt; idx &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span> &lt;&lt; idx &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span> &lt;&lt; nx &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span> &lt;&lt; nx &lt;&lt; endl;<br>        <span class="hljs-type">char</span> ch;cin &gt;&gt; ch;<br>        <span class="hljs-keyword">if</span> (ch == <span class="hljs-string">&#x27;&lt;&#x27;</span>)idx = nx;<br>        nx++;<br>    &#125;<br>    vector&lt;<span class="hljs-type">int</span>&gt;v;<br>    t = n, nx = <span class="hljs-number">0</span>;<br>    v.<span class="hljs-built_in">push_back</span>(nx);<br>    <span class="hljs-type">int</span> ny = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (ny &lt; n) &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;? &quot;</span> &lt;&lt; idx &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span> &lt;&lt; nx &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span> &lt;&lt; idx &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span> &lt;&lt; ny &lt;&lt; endl;<br>        <span class="hljs-type">char</span> ch;cin &gt;&gt; ch;<br>        <span class="hljs-keyword">if</span> (ch == <span class="hljs-string">&#x27;&lt;&#x27;</span>) &#123;<br>            v.<span class="hljs-built_in">clear</span>();<br>            v.<span class="hljs-built_in">push_back</span>(ny);<br>            nx = ny;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ch == <span class="hljs-string">&#x27;=&#x27;</span>) &#123;<br>            v.<span class="hljs-built_in">push_back</span>(ny);<br>        &#125;<br>        ny++;<br>    &#125;<br>    t = v.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, j = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (--t) &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;? &quot;</span> &lt;&lt; v[i] &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span> &lt;&lt; v[i] &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span> &lt;&lt; v[j] &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span> &lt;&lt; v[j] &lt;&lt; endl;<br>        <span class="hljs-type">char</span> ch;cin &gt;&gt; ch;<br>        <span class="hljs-keyword">if</span> (ch == <span class="hljs-string">&#x27;&gt;&#x27;</span>)i = j;<br>        j++;<br>    &#125;<br>    cout &lt;&lt; <span class="hljs-string">&quot;! &quot;</span> &lt;&lt; idx &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span> &lt;&lt; v[i] &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> t;<br>    cin &gt;&gt; t;<br>    <span class="hljs-keyword">while</span> (t--) &#123;<br>        <span class="hljs-built_in">solve</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>ACM</category>
      
      <category>Codeforces</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Codeforces, ACM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Codeforces Round 926 (Div. 2)</title>
    <link href="/2024/03/07/Codeforces/2024.2.29-Codeforces%20Round%20926%20(Div.%202)/"/>
    <url>/2024/03/07/Codeforces/2024.2.29-Codeforces%20Round%20926%20(Div.%202)/</url>
    
    <content type="html"><![CDATA[<blockquote><p>[!Note]</p><p>比赛地址: <a href="https://codeforces.com/contest/1929">Codeforces Round 926 (Div. 2)</a></p><p>完成题目: A~D</p></blockquote><h1 id="Codeforces-Round-926-Div-2"><a href="#Codeforces-Round-926-Div-2" class="headerlink" title="Codeforces Round 926 (Div. 2)"></a>Codeforces Round 926 (Div. 2)</h1><h2 id="A-Sasha-and-the-Beautiful-Array"><a href="#A-Sasha-and-the-Beautiful-Array" class="headerlink" title="A. Sasha and the Beautiful Array"></a>A. Sasha and the Beautiful Array</h2><h3 id="Tags"><a href="#Tags" class="headerlink" title="Tags"></a>Tags</h3><ul><li>算法：数学</li><li>难度：Easy</li></ul><h3 id="Idea"><a href="#Idea" class="headerlink" title="Idea"></a>Idea</h3><p>只要最小值与最大值在两边，最后结果等于最大值-最小值，中间项全部相消了。</p><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">3e5</span> + <span class="hljs-number">5</span>;<br><span class="hljs-type">int</span> n;<br><span class="hljs-type">int</span> a[N];<br><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    cin &gt;&gt; n;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; n;i++)cin &gt;&gt; a[i];<br>    cout &lt;&lt; *<span class="hljs-built_in">max_element</span>(a, a + n) - *<span class="hljs-built_in">min_element</span>(a, a + n) &lt;&lt; endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>    cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);cout.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-type">int</span> t;<br>    cin &gt;&gt; t;<br>    <span class="hljs-keyword">while</span> (t--) &#123;<br>        <span class="hljs-built_in">solve</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="B-Sasha-and-the-Drawing"><a href="#B-Sasha-and-the-Drawing" class="headerlink" title="B. Sasha and the Drawing"></a>B. Sasha and the Drawing</h2><h3 id="Tigs"><a href="#Tigs" class="headerlink" title="Tigs"></a>Tigs</h3><ul><li>算法：思维</li><li>难度：Mid–</li></ul><h3 id="Idea-1"><a href="#Idea-1" class="headerlink" title="Idea"></a>Idea</h3><p>通过画图模拟，可以知道$4*n-2$的来源，其实只用涂色上下两排的方格即可，并且每个方格的贡献如下：</p><div style="text-align: center;"><img src="https://fzttypora.oss-cn-beijing.aliyuncs.com/typora_images/image-20240301215408029.png" alt="image-20240301215408029" style="zoom:50%;" /></div><h3 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">3e5</span> + <span class="hljs-number">5</span>;<br><span class="hljs-type">int</span> n, k;<br><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    cin &gt;&gt; n &gt;&gt; k;<br>    <span class="hljs-keyword">if</span> (k == <span class="hljs-number">4</span> * n - <span class="hljs-number">2</span>) &#123;<br>        cout &lt;&lt; <span class="hljs-number">2</span> * n &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (k == <span class="hljs-number">4</span> * n - <span class="hljs-number">3</span>) &#123;<br>        cout &lt;&lt; <span class="hljs-number">2</span> * n - <span class="hljs-number">1</span> &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (k == <span class="hljs-number">4</span> * n - <span class="hljs-number">4</span>) &#123;<br>        cout &lt;&lt; <span class="hljs-number">2</span> * n - <span class="hljs-number">2</span> &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (k &amp; <span class="hljs-number">1</span>) &#123;<br>        cout &lt;&lt; k / <span class="hljs-number">2</span> + <span class="hljs-number">1</span> &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        cout &lt;&lt; k / <span class="hljs-number">2</span> &lt;&lt; endl;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>    cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);cout.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-type">int</span> t;<br>    cin &gt;&gt; t;<br>    <span class="hljs-keyword">while</span> (t--) &#123;<br>        <span class="hljs-built_in">solve</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="C-Sasha-and-the-Casino"><a href="#C-Sasha-and-the-Casino" class="headerlink" title="C. Sasha and the Casino"></a>C. Sasha and the Casino</h2><h3 id="Tigs-1"><a href="#Tigs-1" class="headerlink" title="Tigs"></a>Tigs</h3><ul><li><p>算法：数学，思维</p></li><li><p>难度：Mid</p></li></ul><h3 id="Idea-2"><a href="#Idea-2" class="headerlink" title="Idea"></a>Idea</h3><p>倍投法：当$k&#x3D;2$，即赔率为$1:1$时，若每次的下注金额为$1、2、4、8…2^n$时，只要赢因此，就会赢1元。</p><p>此题原理相似，只不过$k$不同，并且规定了<strong>最多连续输$x$<strong>次，那么在本金$a$有限的情况下，每次投注尽可能少，又要</strong>保证若此次投注获胜，将会将之前输的都赢回来</strong>，于是有：<br>$$<br>now*(k-1)-pre&gt;0\<br>\text{now为当前投注，pre为之前所有投注之和}<br>$$<br>得到当前应该投注的金额为$now&#x3D;pre&#x2F;(k-1)+1$。$now$从1开始，如此循环，判断连续输$x$局本金是否足够即可。</p><h3 id="Code-2"><a href="#Code-2" class="headerlink" title="Code"></a>Code</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">3e5</span> + <span class="hljs-number">5</span>;<br><span class="hljs-type">int</span> k, x, a;<br><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    cin &gt;&gt; k &gt;&gt; x &gt;&gt; a;<br>    <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>, pre = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= x + <span class="hljs-number">1</span>;i++) &#123;<br>        <span class="hljs-keyword">if</span> (i == <span class="hljs-number">1</span>)ans = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">else</span> ans = pre / (k - <span class="hljs-number">1</span>) + <span class="hljs-number">1</span>;<br>        pre += ans;<br>        <span class="hljs-keyword">if</span> (pre &gt; a) &#123;<br>            cout &lt;&lt; <span class="hljs-string">&quot;NO&quot;</span> &lt;&lt; endl;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>    &#125;<br>    cout &lt;&lt; <span class="hljs-string">&quot;YES&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>    cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);cout.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-type">int</span> t;<br>    cin &gt;&gt; t;<br>    <span class="hljs-keyword">while</span> (t--) &#123;<br>        <span class="hljs-built_in">solve</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="D-Sasha-and-a-Walk-in-the-City"><a href="#D-Sasha-and-a-Walk-in-the-City" class="headerlink" title="D. Sasha and a Walk in the City"></a>D. Sasha and a Walk in the City</h2><h3 id="Tigs-2"><a href="#Tigs-2" class="headerlink" title="Tigs"></a>Tigs</h3><ul><li><p>算法：树上DP，思维</p></li><li><p>难度：Mid++</p></li></ul><h3 id="Idea-3"><a href="#Idea-3" class="headerlink" title="Idea"></a>Idea</h3><p>题目需要保证：<strong>任意一条简单路径，没有出现过三个危险点</strong></p><p>对于上述要求，可以以某一根节点为标准，寻找两个叶子节点，若任意两个叶子节点的路径（$A\to 根 \to B$）都没出现过超过两个以上的危险点，那么即可满足要求。</p><p>于是，对于节点的状态可以设置为：<br>$$<br>\begin{array}{ll}<br>dp[u][0] &amp; :\text{以节点u为根的子树中，最危险的路径上有0个危险点}\<br>dp[u][1] &amp; :\text{以节点u为根的子树中，最危险的路径上有1个危险点}\<br>dp[u][2] &amp; :\text{以节点u为根的子树中，最危险的路径上有2个危险点}\<br>tigs &amp; :\text{最危险的路径为根节点到叶子节点的含有最多危险点的路径}<br>\end{array}<br>$$<br>状态转移如下：<br>$$<br>dp[u][0]&#x3D;1:\text{只有一种情况：包括自身，所有路径都没危险点}\<br>$$</p><p>$$<br>dp[u][1]&#x3D;<br>\left{<br>\begin{matrix}<br>\text{若自身为危险点，那么所有路径都必须没有危险点}:\prod{dp[v][0]}&#x3D;1\<br>\text{若自身不为危险点，那么至少有一个路径有1个危险点，根据容斥可以得}:\prod{(dp[v][0]+dp[v][1])}-\prod{dp[v][0]}<br>\end{matrix}<br>\right.<br>\<br>$$</p><p>$$<br>dp[u][2]&#x3D;<br>\left{<br>\begin{matrix}<br>\text{若自身为危险点，那么只能有一个最危险路径有1个危险点}:\sum{dp[v][1]} \<br>\text{若自身不为危险点，那么只能有一个最危险路径有2个危险点}:\sum{dp[v][2]}<br>\end{matrix}<br>\right.<br>$$</p><h3 id="Code-3"><a href="#Code-3" class="headerlink" title="Code"></a>Code</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">3e5</span> + <span class="hljs-number">5</span>, mod = <span class="hljs-number">998244353</span>;<br><span class="hljs-type">int</span> n;<br>vector&lt;<span class="hljs-type">int</span>&gt;g[N];<br><span class="hljs-type">int</span> dp[N][<span class="hljs-number">3</span>];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">fastpower</span><span class="hljs-params">(<span class="hljs-type">int</span> base, <span class="hljs-type">int</span> power)</span> </span>&#123;<br>    <span class="hljs-type">int</span> ans = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (power) &#123;<br>        <span class="hljs-keyword">if</span> (power &amp; <span class="hljs-number">1</span>)ans = ans * base % mod;<br>        base = base * base % mod;<br>        power &gt;&gt;= <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans % mod;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> fa)</span> </span>&#123;<br>    dp[u][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>, dp[u][<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> v : g[u]) &#123;<br>        <span class="hljs-keyword">if</span> (v == fa)<span class="hljs-keyword">continue</span>;<br>        <span class="hljs-built_in">dfs</span>(v, u);<br>        dp[u][<span class="hljs-number">1</span>] = (dp[u][<span class="hljs-number">1</span>] * (dp[v][<span class="hljs-number">0</span>] + dp[v][<span class="hljs-number">1</span>])) % mod;<br>        dp[u][<span class="hljs-number">2</span>] = (dp[u][<span class="hljs-number">2</span>] + dp[v][<span class="hljs-number">2</span>] + dp[v][<span class="hljs-number">1</span>]) % mod;<br>    &#125;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    cin &gt;&gt; n;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= n;i++) &#123;<br>        g[i].<span class="hljs-built_in">clear</span>();<br>        dp[i][<span class="hljs-number">0</span>] = dp[i][<span class="hljs-number">1</span>] = dp[i][<span class="hljs-number">2</span>] = <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= n - <span class="hljs-number">1</span>;i++) &#123;<br>        <span class="hljs-type">int</span> u, v;<br>        cin &gt;&gt; u &gt;&gt; v;<br>        g[u].<span class="hljs-built_in">push_back</span>(v);<br>        g[v].<span class="hljs-built_in">push_back</span>(u);<br>    &#125;<br>    <span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br>    cout &lt;&lt; (dp[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] + dp[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>] + dp[<span class="hljs-number">1</span>][<span class="hljs-number">2</span>]) % mod &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>    cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);cout.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-type">int</span> t;<br>    cin &gt;&gt; t;<br>    <span class="hljs-keyword">while</span> (t--) &#123;<br>        <span class="hljs-built_in">solve</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>ACM</category>
      
      <category>Codeforces</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Codeforces, ACM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Educational Codeforces Round 162 (Rated for Div. 2)</title>
    <link href="/2024/03/07/Codeforces/2024.2.26-Educational%20Codeforces%20Round%20162%20(Rated%20for%20Div.%202)/"/>
    <url>/2024/03/07/Codeforces/2024.2.26-Educational%20Codeforces%20Round%20162%20(Rated%20for%20Div.%202)/</url>
    
    <content type="html"><![CDATA[<blockquote><p>[!Note]</p><p>比赛地址: <a href="https://codeforces.com/contest/1923">Educational Codeforces Round 162 (Rated for Div. 2)</a></p><p>完成题目: A~D</p></blockquote><blockquote><p>EXAMPLE: Hello world!</p><ul><li>item1</li><li>item2</li></ul><p>still going</p></blockquote><p>+++</p><p>fadljkl</p><p>jdlaj</p><p>杰拉德解放了</p><p>+++</p><p>&#x3D;&#x3D;范泽涛&#x3D;&#x3D;</p><h1 id="Educational-Codeforces-Round-162-Rated-for-Div-2"><a href="#Educational-Codeforces-Round-162-Rated-for-Div-2" class="headerlink" title="Educational Codeforces Round 162 (Rated for Div. 2)"></a>Educational Codeforces Round 162 (Rated for Div. 2)</h1><h2 id="A-Moving-Chips"><a href="#A-Moving-Chips" class="headerlink" title="A. Moving Chips"></a>A. Moving Chips</h2><h3 id="Tags"><a href="#Tags" class="headerlink" title="Tags"></a>Tags</h3><ul><li>算法: 贪心</li><li>难度: Easy</li></ul><h3 id="Idea"><a href="#Idea" class="headerlink" title="Idea"></a>Idea</h3><p>找到第一个1与最后一个1之间有多少个0即可。</p><p>如1001111，每次将最左边的1与最近的0交换，最小交换的次数等于0的个数，两次之后就会变成1111100</p><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">100</span>;<br><span class="hljs-type">int</span> n;<br><span class="hljs-type">int</span> a[N];<br><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    cin &gt;&gt; n;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= n;i++) &#123;<br>        cin &gt;&gt; a[i];<br>    &#125;<br>    <span class="hljs-type">int</span> f = <span class="hljs-number">1</span>, s = n;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= n;i++) &#123;<br>        <span class="hljs-keyword">if</span> (a[i] == <span class="hljs-number">1</span>) &#123;<br>            f = i;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n;i &gt;= <span class="hljs-number">1</span>;i--) &#123;<br>        <span class="hljs-keyword">if</span> (a[i] == <span class="hljs-number">1</span>) &#123;<br>            s = i;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (f == n || f == s) &#123;<br>        cout &lt;&lt; <span class="hljs-number">0</span> &lt;&lt; endl;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-comment">// cout &lt;&lt; f &lt;&lt; &#x27; &#x27; &lt;&lt; s &lt;&lt; endl;</span><br>    <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = f;i &lt;= s;i++) &#123;<br>        <span class="hljs-keyword">if</span> (a[i] == <span class="hljs-number">0</span>) &#123;<br>            ans++;<br>        &#125;<br>    &#125;<br>    cout &lt;&lt; ans &lt;&lt; endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>    cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);cout.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-type">int</span> t;<br>    cin &gt;&gt; t;<br>    <span class="hljs-keyword">while</span> (t--) &#123;<br>        <span class="hljs-built_in">solve</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="B-Monsters-Attack"><a href="#B-Monsters-Attack" class="headerlink" title="B. Monsters Attack!"></a>B. Monsters Attack!</h2><h3 id="Tags-1"><a href="#Tags-1" class="headerlink" title="Tags"></a>Tags</h3><ul><li>算法: 思维，贪心</li><li>难度: Mid–</li></ul><h3 id="Idea-1"><a href="#Idea-1" class="headerlink" title="Idea"></a>Idea</h3><p>贪心打最近的敌人，同时，不用管左边正负，距离相同的敌人是等价的。贪心从最近的敌人打起，维护敌人已经走的步数step以及剩余的子弹，若step大于敌人的距离，那么输出“NO”</p><h3 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">3e5</span> + <span class="hljs-number">5</span>;<br><span class="hljs-type">int</span> n, k;<br><span class="hljs-type">int</span> a[N], x[N];<br><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    cin &gt;&gt; n &gt;&gt; k;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= n;i++) &#123;<br>        cin &gt;&gt; a[i];<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= n;i++) &#123;<br>        cin &gt;&gt; x[i];<br>    &#125;<br>    vector&lt;<span class="hljs-type">int</span>&gt;<span class="hljs-built_in">v</span>(n + <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= n;i++) &#123;<br>        v[<span class="hljs-built_in">abs</span>(x[i])] += a[i];<br>    &#125;<br>    <span class="hljs-comment">// for (int i = 1;i &lt;= n;i++)cout &lt;&lt; v[i] &lt;&lt; &#x27; &#x27;;</span><br>    <span class="hljs-comment">// cout &lt;&lt; endl;</span><br>    <span class="hljs-type">int</span> step = <span class="hljs-number">0</span>, left = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= n;i++) &#123;<br>        <span class="hljs-keyword">if</span> (v[i]) &#123;<br>            <span class="hljs-keyword">if</span> (v[i] &lt;= left) &#123;<br>                left -= v[i];<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                v[i] -= left;<br>                <span class="hljs-type">int</span> temp = (v[i] + k - <span class="hljs-number">1</span>) / k;<br>                left = temp * k - v[i];<br>                step += temp;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (step &gt; i) &#123;<br>                cout &lt;&lt; <span class="hljs-string">&quot;NO&quot;</span> &lt;&lt; endl;<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    cout &lt;&lt; <span class="hljs-string">&quot;YES&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>    cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);cout.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-type">int</span> t;<br>    cin &gt;&gt; t;<br>    <span class="hljs-keyword">while</span> (t--) &#123;<br>        <span class="hljs-built_in">solve</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="C-Find-B"><a href="#C-Find-B" class="headerlink" title="C. Find B"></a><a href="https://codeforces.com/contest/1923/problem/C">C. Find B</a></h2><h3 id="Tags-2"><a href="#Tags-2" class="headerlink" title="Tags"></a>Tags</h3><ul><li>算法: 思维、前缀和</li><li>难度: Mid</li></ul><h3 id="Idea-2"><a href="#Idea-2" class="headerlink" title="Idea"></a>Idea</h3><p>对于长度为len，和为sum数组A，构造数组B。由于构造的数组每个元素必须大于0，那么可以先将数组B每个元素先置为1。对于A数组中非1的元素，B数组保持1不变；对于A数组中为1的元素，B数组中对应的1需要至少加1。若A数组中有x个1，那么需要sum-len&gt;&#x3D;x。</p><h3 id="Code-2"><a href="#Code-2" class="headerlink" title="Code"></a>Code</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">3e5</span> + <span class="hljs-number">5</span>;<br><span class="hljs-type">int</span> n, q;<br><span class="hljs-type">int</span> c[N];<br><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    cin &gt;&gt; n &gt;&gt; q;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= n;i++)cin &gt;&gt; c[i];<br>    vector&lt;<span class="hljs-type">int</span>&gt;<span class="hljs-built_in">x</span>(n + <span class="hljs-number">1</span>), <span class="hljs-built_in">y</span>(n + <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= n;i++) &#123;<br>        x[i] = c[i] + x[i - <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">if</span> (c[i] == <span class="hljs-number">1</span>)y[i] = y[i - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">else</span> y[i] = y[i - <span class="hljs-number">1</span>];<br>    &#125;<br>    <span class="hljs-keyword">while</span> (q--) &#123;<br>        <span class="hljs-type">int</span> l, r;<br>        cin &gt;&gt; l &gt;&gt; r;<br>        <span class="hljs-type">int</span> len = r - l + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (len == <span class="hljs-number">1</span>) &#123;<br>            cout &lt;&lt; <span class="hljs-string">&quot;NO&quot;</span> &lt;&lt; endl;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> sum = x[r] - x[l - <span class="hljs-number">1</span>];<br>        <span class="hljs-type">int</span> num = y[r] - y[l - <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">if</span> (sum - len &gt;= num) &#123;<br>            cout &lt;&lt; <span class="hljs-string">&quot;YES&quot;</span> &lt;&lt; endl;<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            cout &lt;&lt; <span class="hljs-string">&quot;NO&quot;</span> &lt;&lt; endl;<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>    cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);cout.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-type">int</span> t;<br>    cin &gt;&gt; t;<br>    <span class="hljs-keyword">while</span> (t--) &#123;<br>        <span class="hljs-built_in">solve</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="D-Slimes"><a href="#D-Slimes" class="headerlink" title="D. Slimes"></a><a href="https://codeforces.com/contest/1923/problem/D">D. Slimes</a></h2><h3 id="Tags-3"><a href="#Tags-3" class="headerlink" title="Tags"></a>Tags</h3><ul><li>算法: 二分、前缀和</li><li>难度: Mid++</li></ul><h3 id="Idea-3"><a href="#Idea-3" class="headerlink" title="Idea"></a>Idea</h3><p>贪心：对于长度为n的序列，若n个数不全相同，那么它们一定可以加在一起。</p><p>于是，对于<code>a[i]</code>每个数，维护其左边前缀和以及右边后缀和，二分查找左边&#x2F;右边第一个前缀和&#x2F;后缀和大于<code>a[i]</code>的端点即可。但是需要判断该子串是否元素不全相同。若全相同，则需另外找该端点左侧&#x2F;右侧第一个不同的元素的位置。</p><p>判断某子串元素是否全相同，可以维护每个元素左边&#x2F;右边第一个不同的元素的位置。</p><h3 id="Code-3"><a href="#Code-3" class="headerlink" title="Code"></a>Code</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">3e5</span> + <span class="hljs-number">5</span>;<br><span class="hljs-type">int</span> n;<br><span class="hljs-type">int</span> a[N];<br><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    cin &gt;&gt; n;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= n;i++)cin &gt;&gt; a[i];<br>    vector&lt;<span class="hljs-type">int</span>&gt;<span class="hljs-built_in">l</span>(n + <span class="hljs-number">10</span>), <span class="hljs-built_in">r</span>(n + <span class="hljs-number">10</span>);<br>    a[<span class="hljs-number">0</span>] = a[n + <span class="hljs-number">1</span>] = <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= n;i++) &#123;<br>        <span class="hljs-keyword">if</span> (a[i] != a[i - <span class="hljs-number">1</span>])l[i] = i - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">else</span> l[i] = l[i - <span class="hljs-number">1</span>];<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n;i &gt;= <span class="hljs-number">1</span>;i--) &#123;<br>        <span class="hljs-keyword">if</span> (a[i] != a[i + <span class="hljs-number">1</span>])r[i] = i + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">else</span> r[i] = r[i + <span class="hljs-number">1</span>];<br>    &#125;<br>    vector&lt;<span class="hljs-type">int</span>&gt;<span class="hljs-built_in">sum</span>(n + <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= n;i++)sum[i] = sum[i - <span class="hljs-number">1</span>] + a[i];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= n;i++) &#123;<br>        <span class="hljs-type">int</span> res = <span class="hljs-number">1e18</span>;<br>        <span class="hljs-comment">// 左边</span><br>        <span class="hljs-keyword">if</span> (sum[i - <span class="hljs-number">1</span>] &gt; a[i]) &#123;<br>            <span class="hljs-type">int</span> x = <span class="hljs-number">1</span>, y = i - <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">while</span> (x &lt; y) &#123;<br>                <span class="hljs-type">int</span> mid = (x + y + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;<br>                <span class="hljs-keyword">if</span> (sum[i - <span class="hljs-number">1</span>] - sum[mid - <span class="hljs-number">1</span>] &gt; a[i]) &#123;<br>                    x = mid;<br>                &#125;<br>                <span class="hljs-keyword">else</span> &#123;<br>                    y = mid - <span class="hljs-number">1</span>;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (i - x == <span class="hljs-number">1</span>) &#123;<br>                res = <span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (r[x] &lt;= i - <span class="hljs-number">1</span>) &#123;<br>                res = <span class="hljs-built_in">min</span>(res, i - x);<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">if</span> (l[x] != <span class="hljs-number">0</span>) &#123;<br>                    res = <span class="hljs-built_in">min</span>(res, i - l[x]);<br>                &#125;<br>            &#125;<br><br>        &#125;<br>        <span class="hljs-comment">// 右边</span><br>        <span class="hljs-keyword">if</span> (sum[n] - sum[i] &gt; a[i]) &#123;<br>            <span class="hljs-type">int</span> x = i + <span class="hljs-number">1</span>, y = n;<br>            <span class="hljs-keyword">while</span> (x &lt; y) &#123;<br>                <span class="hljs-type">int</span> mid = (x + y) / <span class="hljs-number">2</span>;<br>                <span class="hljs-keyword">if</span> (sum[mid] - sum[i] &gt; a[i])y = mid;<br>                <span class="hljs-keyword">else</span> x = mid + <span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (y - i == <span class="hljs-number">1</span>)res = <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span> (l[y] &gt;= i + <span class="hljs-number">1</span>) &#123;<br>                res = <span class="hljs-built_in">min</span>(res, y - i);<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">if</span> (r[y] != n + <span class="hljs-number">1</span>) &#123;<br>                    res = <span class="hljs-built_in">min</span>(res, r[y] - i);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (res == <span class="hljs-number">1e18</span>)cout &lt;&lt; <span class="hljs-number">-1</span> &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>;<br>        <span class="hljs-keyword">else</span> cout &lt;&lt; res &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>;<br>    &#125;<br>    cout &lt;&lt; endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>    cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);cout.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-type">int</span> t;<br>    cin &gt;&gt; t;<br>    <span class="hljs-keyword">while</span> (t--) &#123;<br>        <span class="hljs-built_in">solve</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>ACM</category>
      
      <category>Codeforces</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Codeforces, ACM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第 4 章 表达式</title>
    <link href="/2024/03/07/C++/C++%20Primer/%E7%AC%AC%204%20%E7%AB%A0%20%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <url>/2024/03/07/C++/C++%20Primer/%E7%AC%AC%204%20%E7%AB%A0%20%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="第-4-章-表达式"><a href="#第-4-章-表达式" class="headerlink" title="第 4 章 表达式"></a>第 4 章 表达式</h1><p>表达式由一个或多个 <strong>运算对象</strong> 组成, 对表达式求值将得到一个 <strong>结果</strong>. <strong>字面值和变量是最简单的表达式</strong>, 其结果就是它们本身. <strong>运算符</strong> 和一个或多个运算对象组合起来可以生成较为复杂的表达式.</p><h2 id="4-1-基础"><a href="#4-1-基础" class="headerlink" title="4.1 基础"></a>4.1 基础</h2><h3 id="4-1-1-基本概念"><a href="#4-1-1-基本概念" class="headerlink" title="4.1.1 基本概念"></a>4.1.1 基本概念</h3><p>C++ 根据运算符作用的运算对象个数不同定义了 <strong>一元运算符, 二元运算符, 三元运算符</strong>. 一些符号既能作为一元运算符又能作为二元运算符, 其含义由上下文决定.</p><blockquote><p><strong>函数调用</strong> 是一种特殊的运算符, 它对运算对象的数量没有限制.</p></blockquote><h4 id="组合运算符和运算对象"><a href="#组合运算符和运算对象" class="headerlink" title="组合运算符和运算对象"></a>组合运算符和运算对象</h4><p>表达式的含义与 <strong>运算符的优先级, 结合率, 运算对象的求值顺序</strong> 有关.</p><h4 id="运算对象转换"><a href="#运算对象转换" class="headerlink" title="运算对象转换"></a>运算对象转换</h4><p>表达式求值过程中, 运算对象类型可以转换成另一种类型. 小整数类型 (如 bool, char, short 等) 通常会 <strong>提升</strong> 为较大整数类型, 主要是 int.</p><h4 id="重载运算符"><a href="#重载运算符" class="headerlink" title="重载运算符"></a>重载运算符</h4><p>重载运算符: 为已存在的运算符赋予另一层含义.</p><p>重载运算符需要定义运算对象和返回值的类型, 但是 <strong>运算对象的个数, 运算符的优先级和结合律都无法改变</strong>.</p><h4 id="左值和右值"><a href="#左值和右值" class="headerlink" title="左值和右值"></a>左值和右值</h4><p>C++ 中表达式非 <strong>左值</strong> 即 <strong>右值</strong>. 当一个运算对象被用作右值的时候, 用的是对象的 <strong>值 (内容)</strong>; 当对象被用作左值时, 用的是对象的 <strong>身份 (在内存中的位置)</strong>.</p><p>一个重要原则: <u> 需要用右值的地方可以被左值替换 (使用左值的内容), 但不能将右值替换左值使用 </u>.</p><blockquote><p>若表达式的求值结果是左值, <code>decltype</code> 作用于该表达式 (不是变量) 将得到一个 <strong>引用类型</strong>.</p><p>假定 p 的类型是 <code>int*</code></p><ul><li><code>*p</code> 产生左值, 所以 <code>decltype(*p)</code> 的结果是 <code>int&amp;</code>.</li><li><code>&amp;p</code> 产生右值, 所以 <code>decltype(&amp;p)</code> 的结果是 <code>int**</code>.</li></ul></blockquote><h3 id="4-1-2-优先级与结合律"><a href="#4-1-2-优先级与结合律" class="headerlink" title="4.1.2 优先级与结合律"></a>4.1.2 优先级与结合律</h3><p><strong>复合表达式</strong>: 含有两个或多个运算符的表达式. 运算符的优先级和结合律决定了运算对象的组合方式. 括号无视普通的组合规则, 表达式中括号括起来的部分被当成一个单元来求值.</p><h3 id="4-1-3-求值顺序"><a href="#4-1-3-求值顺序" class="headerlink" title="4.1.3 求值顺序"></a>4.1.3 求值顺序</h3><p><strong>优先级和结合律规定了运算对象的组合方式, 但是未规定求值顺序.</strong> C++ 中有 4 种运算符明确规定了运算对象的求值顺序:</p><ol><li>与运算符: <code>&amp;</code></li><li>或运算符: <code>|</code></li><li>条件运算符: <code>?:</code></li><li>逗号运算符: <code>,</code></li></ol><p>对于那些未规定执行顺序的运算符, <u> 如果表达式指向并修改了同一对象, 将会引发错误并产生未定义的行为 </u>. </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> x=<span class="hljs-built_in">f</span>()+<span class="hljs-built_in">g</span>()*<span class="hljs-built_in">h</span>()+<span class="hljs-built_in">j</span>()<br></code></pre></td></tr></table></figure><p>如上述表达式:</p><ul><li>优先级规定: <code>g()</code> 的返回值与 <code>h()</code> 的返回值相乘</li><li>结合律规定: <code>f()</code> 的返回值先与 <code>g()*h()</code> 相加, 所得结果在与 <code>j()</code> 返回值相加</li><li>对于这些函数调用顺序没有明确的规定.</li></ul><p>若 f, g, h , j 函数相互无关, 那么函数的调用的顺序不受限制. 反之, 若几个函数影响同一对象, 那么它将产生未定义的行为.</p><blockquote><ul><li><p>在不确定的时候用括号来强制规定表达式的逻辑关系.</p></li><li><p>如果改变了某个运算对象的值, 在表达式的其他地方不要再使用这个运算对象. 除非改变运算对象的子表达式本身是另一个子表达式的运算对象 (如 <code>*++iter</code>).</p></li></ul></blockquote><h2 id="4-2-算术运算符"><a href="#4-2-算术运算符" class="headerlink" title="4.2 算术运算符"></a>4.2 算术运算符</h2><div style="text-align: center;"> <img src="https://fzttypora.oss-cn-beijing.aliyuncs.com/typora_images/image-20240304183244183.png" alt="算术运算符" /> </div><p>算术运算符优先级如上所示, 遵循 <strong>左结合律</strong>, 运算对象和求值结果都是 <strong>右值</strong>.</p><ul><li><em>一元正号运算符, 加法运算符, 减法运算符都能作用于指针.</em></li><li>一元正号运算符作用于指针或者算术值时, 返回运算对象值的一个 (提升后的) 副本.</li><li>一元负号运算符对运算对象值取负后, 返回运算对象值的一个 (提升后的) 副本.</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">bool</span> b=<span class="hljs-literal">true</span>; <span class="hljs-comment">// b 为bool类型</span><br>cout &lt;&lt; <span class="hljs-built_in">typeid</span>(-b).<span class="hljs-built_in">name</span>() &lt;&lt; endl; <span class="hljs-comment">// -b 的类型实际上为 int 类型, 表示 -1</span><br></code></pre></td></tr></table></figure><p>对于 <code>/</code>, 整数的运算结果还是整数, 同时 <strong>向 0 取整</strong>. 对于 <code>%</code> 运算, 运算结果的 <strong>正负取决于分子的符号, 与分母符号无关</strong>.即有: $(-m)&#x2F;n &#x3D; m&#x2F;(-n)&#x3D; -(m&#x2F;n), (-m)%n&#x3D;-(m%n), m%(-n)&#x3D;m%n$</p><h2 id="4-3-逻辑和关系运算符"><a href="#4-3-逻辑和关系运算符" class="headerlink" title="4.3 逻辑和关系运算符"></a>4.3 逻辑和关系运算符</h2><div style="text-align: center;"> <img src="https://fzttypora.oss-cn-beijing.aliyuncs.com/typora_images/image-20240304192050379.png" alt="image-20240304192050379" /> </div><p>逻辑运算符和关系运算符返回值都是布尔类型, 其中 <strong>关系运算符满足左结合律</strong>, 运算结果都是 <strong>右值</strong>.</p><p>逻辑与和逻辑或运算符具有 <strong>短路求值</strong> 的特点:</p><ul><li>对于逻辑与运算符来说, 当且仅当左侧运算对象为真时才对右侧运算对象求值.</li><li>对于逻辑或运算符来说, 当且仅当左侧运算对象为假时才对右侧运算对象求值.</li></ul><blockquote><p>进行比较运算时, 除非比较的对象为 bool 型, 否则不要用布尔字面值 true and false 作为比较对象.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">if</span> (val == <span class="hljs-literal">true</span>)...;<br><span class="hljs-comment">// 当 val 为 bool 类型时, 比较运算不会有问题.</span><br><span class="hljs-comment">// 当 val 为 int 类型时, 会将 true 转换成 1, 表达式变为 if (val == 1), 比较运算与预期效果不符.</span><br></code></pre></td></tr></table></figure></blockquote><h2 id="4-4-赋值运算符"><a href="#4-4-赋值运算符" class="headerlink" title="4.4 赋值运算符"></a>4.4 赋值运算符</h2><p>赋值运算符 <strong>左侧运算对象必须是左值, 结果类型是左侧运算对象的类型</strong>.</p><p>可以使用初始值列表作为赋值运算符右侧运算对象, 若左侧运算对象是内置类型, 那么初始值列表最多只能包含一个值, <strong>小心类型转换过程中是否有信息损失的风险</strong>: 该值所占空间也不应该大于目标类型空间.</p><p>无论左侧运算对象的类型是什么, 初始值列表都可以为空, 此时, 编译器创建一个 <strong>值初始化</strong> 的临时量赋值给左侧.</p><h3 id="赋值运算符满足右结合律"><a href="#赋值运算符满足右结合律" class="headerlink" title="赋值运算符满足右结合律"></a>赋值运算符满足右结合律</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> i,j;<br>i=j=<span class="hljs-number">0</span>;<br></code></pre></td></tr></table></figure><p>首先执行 <code>j=0</code>, 返回左侧运算对象即 <code>j</code>, 在执行 <code>i=j</code>.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> i, *j;<br>i=j=<span class="hljs-number">0</span>;<br></code></pre></td></tr></table></figure><p>即便 0 可以为指针与整型赋值, 但是 , 指针不能赋值给 <code>int</code> 类型, 因此上述是错误的. <u> 多重赋值语句中每一个对象, 它的对象与右侧对象相同或可以由其转换而来 </u>.</p><blockquote><p>谨慎赋值运算符在条件判断过程中的使用, 赋值运算符的优先级较低.</p></blockquote><h3 id="复合赋值运算符"><a href="#复合赋值运算符" class="headerlink" title="复合赋值运算符"></a>复合赋值运算符</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">+=, -=, *=, /=, %=;<span class="hljs-comment">// 算术运算符</span><br>&lt;&lt;=, &gt;&gt;=, &amp;=, ^=, |=;<span class="hljs-comment">// 位运算符</span><br></code></pre></td></tr></table></figure><p>等价于 <code>a = a op b;</code></p><h2 id="4-5-递增和递减运算符"><a href="#4-5-递增和递减运算符" class="headerlink" title="4.5 递增和递减运算符"></a>4.5 递增和递减运算符</h2><p>递增递减运算符必须作用于 <strong>左值</strong> 运算对象. 前置版本将 <strong>对象本身作为左值返回</strong>, 后置版本将 <strong>对象原始值的副本作为右值返回</strong>.</p><blockquote><p><strong>除非必要, 否则不用递增递减运算符的后置版本</strong>: 因为后置版本需要保存元素对象的副本, 对于复杂的迭代器类型来说, 额外的工作量会增加很多.</p></blockquote><h3 id="在一条语句中混用解引用和递增运算符"><a href="#在一条语句中混用解引用和递增运算符" class="headerlink" title="在一条语句中混用解引用和递增运算符"></a>在一条语句中混用解引用和递增运算符</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">auto</span> x=v.<span class="hljs-built_in">begin</span>();<br><span class="hljs-keyword">while</span>(x != v.<span class="hljs-built_in">end</span>() &amp;&amp; *x&gt;=<span class="hljs-number">0</span>)&#123;<br>    cout&lt;&lt; *x++ &lt;&lt;endl;<br>&#125;<br></code></pre></td></tr></table></figure><p>上述结果先执行 <code>x++</code>, <code>*</code> 作用于 <code>x</code> 原来指向的值. 效果是: <u> 输出 <code>x</code> 开始指向的哪个元素, 并将指针向前移动一个单位 </u>.</p><h3 id="运算对象的求值顺序未规定"><a href="#运算对象的求值顺序未规定" class="headerlink" title="运算对象的求值顺序未规定"></a>运算对象的求值顺序未规定</h3><p><u> 注意递增递减运算符会改变运算对象, 这时需要关注运算对象的求值顺序, 是否会产生未定义的行为.</u></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">while</span>(beg!=s.<span class="hljs-built_in">end</span>() &amp;&amp; !<span class="hljs-built_in">isspace</span>(*beg))&#123;<br>    *beg = <span class="hljs-built_in">toupper</span>(*beg++);<span class="hljs-comment">// 错误: 该赋值语句未定义</span><br>&#125;<br></code></pre></td></tr></table></figure><p>赋值运算符两端都使用了 beg, 并且左侧运算对象改变了 beg 的值, 所以上述赋值语句是未定义的.</p><h2 id="4-6-成员访问运算符"><a href="#4-6-成员访问运算符" class="headerlink" title="4.6 成员访问运算符"></a>4.6 成员访问运算符</h2><p><code>ptr -&gt; men</code> 等价于 <code>(*ptr).mem</code>. </p><ul><li>箭头运算符结果是 <strong>左值</strong>.</li><li>点运算符: 当成员所属的对象是左值, 结果为左值; 当成员所属的对象是右值, 结果为右值.</li></ul><p>注意 <code>*</code> 的优先级低于 <code>.</code>, 上述括号不可省略.</p><h2 id="4-7-条件运算符"><a href="#4-7-条件运算符" class="headerlink" title="4.7 条件运算符"></a>4.7 条件运算符</h2><p><code>cond ? expr1 : expr2;</code></p><ul><li><strong>条件运算符规定了求值顺序</strong>: 先计算 <code>cond</code> , 若 <code>cond</code> 为真, 对 <code>expr1</code> 求值并返回结果; 否则, 对 <code>expr2</code> 求值并返回结果.</li><li>当条件运算符的两个表达式都是左值或能转换成同一种左值类型时, 运算的结果是左值; 否则运算结果为右值.</li><li>条件运算符满足 <strong>右结合律</strong>.</li></ul><h3 id="嵌套条件运算符"><a href="#嵌套条件运算符" class="headerlink" title="嵌套条件运算符"></a>嵌套条件运算符</h3><p><code>a ? b : c ? d : e;</code></p><p>注意, <strong>结合律与求值顺序无关, 其只能说明运算对象的组合方式</strong>. 虽然条件运算符满足右结合律, 但是, 上述求值顺序仍然是: 先判断 <code>a</code> 的真值, 在以此来求 <code>b</code> 或者判断 <code>c</code> 的真值.</p><p>只不过, 上述运算对象的组合方式是: <code>a ? b : (c ? d : e);</code></p><h3 id="在输出表达式中使用条件运算符"><a href="#在输出表达式中使用条件运算符" class="headerlink" title="在输出表达式中使用条件运算符"></a>在输出表达式中使用条件运算符</h3><p>注意 <strong>条件运算符的优先级非常低, 低于 <code>&lt;&lt;</code></strong>.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++">cout&lt;&lt; ((a&lt;<span class="hljs-number">100</span>)?f:t);<span class="hljs-comment">// 输出 f or t</span><br>cout&lt;&lt; (a&lt;<span class="hljs-number">100</span>)?f:t;<span class="hljs-comment">// 输出 a&lt;100 的结果</span><br>cout&lt;&lt; a&lt;<span class="hljs-number">100</span>?f:t;<span class="hljs-comment">// 错误: 试图比较cout 与 100</span><br></code></pre></td></tr></table></figure><p>第二条语句等价于:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">cout&lt;&lt; (a&lt;<span class="hljs-number">100</span>);<br>cout ?f:t;<br></code></pre></td></tr></table></figure><p>第三条语句等价于:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">cout&lt;&lt;a;<br>cout&lt;<span class="hljs-number">100</span>?f:t;<br></code></pre></td></tr></table></figure><h2 id="4-8-位运算符"><a href="#4-8-位运算符" class="headerlink" title="4.8 位运算符"></a>4.8 位运算符</h2><p>位运算符作用于整数类型, bitset 类型. 其将运算对象看成二进制位的集合.</p><div style="text-align:center;"> <img src="https://fzttypora.oss-cn-beijing.aliyuncs.com/typora_images/image-20240305114900117.png" alt="位运算符" /> </div><p>若运算对象是小整数类型, 那么它的值会被 <strong>提升</strong>. 同时, 运算对象可以是带符号类型 or 无符号类型, <strong>若处理带符号类型, 位运算符的处理方式依赖于机器</strong>. 并且, 由于左移操作可能会改变符号位, 因此是一种未定义的行为.</p><ul><li>左移运算符: 在右侧插入 0.</li><li>右移运算符: 依赖于左侧运算对象的类型<ul><li>运算对象为无符号类型, 在左侧插入 0.</li><li>运算对象为有符号类型, 在左侧插入符号位的副本或者 0, 如何选取视具体环境而定.</li></ul></li></ul><p>移位运算符满足 <strong>左结合律</strong>, 同时重载成 IO 运算符后, 其优先级和结合律是不会变的. 此时需要注意移位运算符的优先级:</p><ul><li>比算术运算符优先级低.</li><li>比关系运算符, 逻辑运算符, 赋值运算符, 条件运算符优先级高.</li></ul><h2 id="4-9-sizeof-运算符"><a href="#4-9-sizeof-运算符" class="headerlink" title="4.9 sizeof 运算符"></a>4.9 sizeof 运算符</h2><p><code>sizeof</code> 运算符返回一条 <strong>表达式</strong> 或者一个 <strong>类型名字</strong> 所占的字节数. 满足 <strong>右结合律</strong>, 返回 <code>size_t</code> 类型的 <strong>常量表达式</strong>. 运算符的运算对象有两种形式:</p><ul><li><code>sizeof (type)</code></li><li><code>sizeof expr</code></li></ul><p>注意, <strong><code>sizeof</code> 不会实际计算运算对象的值</strong>.</p><p><code>sizeof</code> 的结果部分依赖于其所作用的类型:</p><ul><li>对 <code>char</code> 类型或者类型为 <code>char</code> 的表达式: 结果为 1.</li><li>对于 <code>引用</code> 类型: 结果为被引用对象所占的空间大小.</li><li>对于 <code>指针</code> 类型: 结果为指针本身所占的空间大小.</li><li>对于 <code>解引用指针</code> : 结果为指针指向对象所占空间的大小, <strong>指针不需要有效</strong>.</li><li>对于 <code>数组</code> 类型: 结果为整个数组所占空间大小. <strong>注意 <code>sizeof</code> 不会将数组转换成指针来处理</strong>.</li><li>对于 <code>string</code>  or <code>vector</code> 类型: <em>结果返回该类型固定部分的大小, 不会计算对象中的元素占用了多少空间</em>.</li></ul><p>可以利用 <code>sizeof</code> 来计算数组中元素的个数, 同时由于返回结果是常量表达式, 可以用 <code>sizeof</code> 的结果声明数组的维度.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> a[<span class="hljs-number">10</span>];<br><span class="hljs-keyword">constexpr</span> <span class="hljs-type">size_t</span> sz=<span class="hljs-built_in">sizeof</span>(a)/<span class="hljs-built_in">sizeof</span>(*a);<br></code></pre></td></tr></table></figure><h2 id="4-10-类型转换"><a href="#4-10-类型转换" class="headerlink" title="4.10 类型转换"></a>4.10 类型转换</h2><p>若两种类型可以 <strong>相互转换</strong>, 那么它们就是关联的.</p><p><strong>隐式转换</strong>: 类型转换是自动进行的, 无须程序员的介入. 有以下几种情况会发生隐式类型转换:</p><ul><li>在大多数表达式中, <strong>比 int 类型小的整型值首先提升为较大的整数类型</strong>.</li><li>在条件中, 非布尔值转换成布尔值.</li><li>初始化过程中, 初始值转换成变量的类型; <strong>在赋值语句中, 右侧运算对象转换成左侧运算对象的类型</strong>.</li><li>如果算术运算或者关系运算的运算对象有多种类型, 需转化成同一种类型.</li><li>函数调用时也会发生类型转换.</li></ul><h3 id="4-11-1-算术转换"><a href="#4-11-1-算术转换" class="headerlink" title="4.11.1 算术转换"></a>4.11.1 算术转换</h3><p>算术转换: 将一种算术类型转换成另一种算术类型. 算术转换定义了一套类型转换的层次, 其中运算符的运算对象将转换成 <strong>最宽的类型</strong>.</p><h4 id="整数提升"><a href="#整数提升" class="headerlink" title="整数提升"></a>整数提升</h4><p>将小整数类型转换成较大的整数类型.</p><ul><li><code>bool, char, short char, unsigned char, short, unsigned short</code> 等类型, 若它们的值都能存在 <code>int</code> 里, 它们会提升为 <code>int</code> 类型; 否则, 提升为 <code>unsigned int</code> 类型.</li><li>较大的 <code>char</code> 类型, 如 <code>wchar_t, char16_t, char32_t</code> 提升为 <code>int, unsigned int, long, unsigned long, long long, unsigned long long</code> 中的能容纳原来类型的最小类型.</li></ul><h4 id="无符号类型的运算对象"><a href="#无符号类型的运算对象" class="headerlink" title="无符号类型的运算对象"></a>无符号类型的运算对象</h4><p>对于无符号类型的运算对象, 首先进行整数提升:</p><ul><li>若 (提升后) 运算对象都是有符号, 或者都是无符号类型, 那么小类型的运算对象转换成较大的类型.</li><li>若既有无符号类型运算对象, 也有有符号类型运算对象<ul><li>若无符号类型 &gt;&#x3D; 有符号类型: 有符号类型转换成无符号类型. 如 <code>int</code> -&gt; <code>unsigned int</code></li><li>若无符号类型 &lt; 有符号类型: 转换结果依赖于机器<ul><li>若无符号类型所有值都能存在于该有符号类型中, 那么无符号类型转换成有符号类型</li><li>否则, 有符号类型转换成无符号类型.</li></ul></li></ul></li></ul><h3 id="4-11-2-其他隐式类型转换"><a href="#4-11-2-其他隐式类型转换" class="headerlink" title="4.11.2 其他隐式类型转换"></a>4.11.2 其他隐式类型转换</h3><ul><li><strong>数组转换成指针</strong>: 注意在 <code>decltype, &amp;, sizeof, typeid</code> 中, 上述转换不会发生.</li><li><strong>指针的转换</strong>:<ul><li>整数 0 或字面值 <code>nullptr</code> 能转换成任意指针类型.</li><li>指向任意非常量的指针能转换成 <code>void*</code>.</li><li>指向任意对象的指针能转换成 <code>const void*</code>.</li></ul></li><li><strong>转换成布尔类型</strong>: 算术类型或指针可以转换为布尔类型</li><li><strong>转换成常量</strong>: 指向非常量类型的指针转换成指向常量类型的指针, 对引用同样适用. (反向不适用)</li><li><strong>类类型定义的转换</strong>: 类类型能定义由编译器自动执行转换, 不过编译器 <strong>每次只能执行一次类类型的转换</strong>. 如字符串字面值 to <code>string</code> 的转换, <code>cin</code> to <code>bool</code> 的转换.</li></ul><h3 id="4-11-3-显式转换"><a href="#4-11-3-显式转换" class="headerlink" title="4.11.3 显式转换"></a>4.11.3 显式转换</h3><p><strong>强制类型转换</strong> 的格式: <code>cast-name&lt;type&gt;(expression)</code>.</p><ul><li><code>canst-name</code>: 指定转换的类型, 有 <code>static_cast, dynamic_cast, const_cast, reinterpret_cast</code>.</li><li><code>type</code>: 目标类型</li><li><code>expression</code>: 要转换的对象</li></ul><h4 id="static-cast"><a href="#static-cast" class="headerlink" title="static_cast"></a>static_cast</h4><p>任何具有明确定义的类型转换, 只要不包含底层 const, 都可以使用 static_cast. 以下是 static_cast 的常用之处:</p><ul><li>当需要把较大算术类型转换为较小算术类型, 此时尽管会有精度损失, 编译器不会警告.</li><li>编译器无法自动执行的类型转换, 如找回 <code>void*</code> 原来的类型.</li></ul><h4 id="const-cast"><a href="#const-cast" class="headerlink" title="const_cast"></a>const_cast</h4><p><strong>const_cast 只能改变运算对象的底层 const</strong>. 且只有 cosnt_cast 能改变表达式的常量属性, 其他形式的强制类型转换改变表达式的常量属性都会引发编译错误.</p><p>对于将常量对象转化为非常量对象, 称为 “去掉 const 性质”. 一旦去掉 const 性质, 就获得了对该对象的写权限.</p><p>如果对象本身不是一个常量, 去 cosnt 性质是合法的.  但是, <strong>若对象本身就是一个常量, 此时去 const 性质后执行写操作会产生未定义的行为.</strong></p><p>const_cast 常用于有 <strong>函数重载</strong> 的上下文中.</p><h4 id="reinterpret-cast"><a href="#reinterpret-cast" class="headerlink" title="reinterpret_cast"></a>reinterpret_cast</h4><p><em>reinterpret_cast 通常为运算对象的位模式提供较低层次上的重新解释.</em></p><h4 id="旧强制类型转换"><a href="#旧强制类型转换" class="headerlink" title="旧强制类型转换"></a>旧强制类型转换</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">type</span> (expr); <span class="hljs-comment">// 函数形式的强制类型转换</span><br>(type) expr; <span class="hljs-comment">// C 语言风格的强制类型转换</span><br></code></pre></td></tr></table></figure><p>旧强制类型转换分别具有与 const_cast, static_cast, reinterpret_cast 相似的行为, 似具体情况而定.</p><ul><li>若换成 const_cast 和 static_cast 也合法, 则其行为与对应的命名转换一致.</li><li>如果替换后不合法, 旧强制类型转换会执行与 reinterpret_cast 类似的功能.</li></ul>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
      <category>C++ Primer 学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第 5 章 语句</title>
    <link href="/2024/03/06/C++/C++%20Primer/%E7%AC%AC%205%20%E7%AB%A0%20%E8%AF%AD%E5%8F%A5/"/>
    <url>/2024/03/06/C++/C++%20Primer/%E7%AC%AC%205%20%E7%AB%A0%20%E8%AF%AD%E5%8F%A5/</url>
    
    <content type="html"><![CDATA[<h1 id="第-5-章-语句"><a href="#第-5-章-语句" class="headerlink" title="第 5 章 语句"></a>第 5 章 语句</h1><h2 id="5-1-简单语句"><a href="#5-1-简单语句" class="headerlink" title="5.1 简单语句"></a>5.1 简单语句</h2><ul><li><p><strong>表达式语句</strong>: 表达式 + <code>;</code> 就形成表达式语句, 其作用是执行表达式并丢掉求值结果.</p></li><li><p><strong>空语句</strong>: 只含一个单独的 <code>;</code>, 逻辑上不需要, 但语法上需要的语句时使用.</p></li><li><p><strong>复合语句 (块)</strong>: 用花括号括起来的语句和声明序列, 一个块就是一个作用域. 语法上需要一条语句, 逻辑上需要多条语句时使用. 空块类似于空语句.</p></li></ul><blockquote><p>[!Tip]</p><p>使用空语句时应该加上注释.</p></blockquote><blockquote><p>[!Warning]</p><ul><li>多余的空语句并非无害的.</li><li>块不以分号作为结束.</li></ul></blockquote><h2 id="5-2-条件语句"><a href="#5-2-条件语句" class="headerlink" title="5.2 条件语句"></a>5.2 条件语句</h2><h3 id="5-2-1-if-语句"><a href="#5-2-1-if-语句" class="headerlink" title="5.2.1 if 语句"></a>5.2.1 if 语句</h3><p><strong>if 语句</strong>: 判断一个指定的条件是否为真, 根据判断结果决定是否执行另一条语句.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 语法形式</span><br><span class="hljs-comment">// 含 else 分支</span><br><span class="hljs-keyword">if</span> (condition)<br>    statement;<br><span class="hljs-keyword">else</span><br>    statement2;<br><span class="hljs-comment">// 不含 else 分支</span><br><span class="hljs-keyword">if</span> (condition)<br>    statement;<br></code></pre></td></tr></table></figure><blockquote><p>[!Tip]</p><p>使用 if, while, for 等语句时, 最好使用花括号. 避免代码混淆不清, 同时可以方便添加代码.</p></blockquote><p>if-else 的匹配问题: 对于 <strong>悬垂 else</strong>, C++ 规定 <strong>else 与它最近的尚未匹配的 if 匹配</strong>. 同时, 可以使用花括号来控制执行路径.</p><h3 id="5-2-2-switch-语句"><a href="#5-2-2-switch-语句" class="headerlink" title="5.2.2 switch 语句"></a>5.2.2 switch 语句</h3><p><strong>switch 语句</strong>: 方便在多个固定选项中做出选择.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">switch</span> (ch) &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;a&#x27;</span>:<br>        statement1;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;b&#x27;</span>:<br>        statement2;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;c&#x27;</span>:<br>        statement3;<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;d&#x27;</span>:<br>        statement4;<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">default</span>:<br>        statement5;<br>        <span class="hljs-keyword">break</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>case 标签</strong>: case 关键字和它对应的值一起被称为 case 标签.</p><blockquote><p>[!Warning]</p><ul><li>case 标签必须是 <strong>整形常量表达式</strong>.</li><li>case 标签的值不能相同.</li></ul></blockquote><h4 id="switch-内部的控制流"><a href="#switch-内部的控制流" class="headerlink" title="switch 内部的控制流"></a>switch 内部的控制流</h4><p>如果某个 case 标签匹配成功, 将从该标签开始往后顺序执行 <strong>所有 case 分支</strong>, 除非程序显示中断这一过程, 否则直到 switch 的结尾处才会停止.</p><p><strong>default 标签</strong>: 若无法找到对应的 case 标签, 若有 default 声明, 程序将跳转到 default 处; 否则, 程序会跳转到 switch 的下一条语句.</p><blockquote><p>[!Tip]</p><p>即使不准备在 defualt 标签下做任何工作, 也尽量添加 default 标签. 以告诉读者我们考虑了默认的情况.</p></blockquote><p>为了避免执行后续 case 分支, 需要显示的添加 break 语句. 若想让多个 case 分支匹配同一条语句, 则可以故意省略 break 语句.</p><blockquote><p>[!Warning]</p><p>标签不应独立存在, 其后面必须跟上一条语句或另一个 case 标签.</p></blockquote><h4 id="switch-内部的变量定义"><a href="#switch-内部的变量定义" class="headerlink" title="switch 内部的变量定义"></a>switch 内部的变量定义</h4><p>若匹配到某个特定 case 标签, switch 结构中该 case 标签之前的部分会被忽略. 但是若先前的 “变量的定义” 被忽略了, 后续使用该变量会出现一些问题.</p><p>对于 C++ : <strong>如果在某处一个带有初值的变量位于作用域之外, 在另一处该变量位于作用域之内, 则从前一处跳转到后一处的行为是非法的</strong>. 即 <strong>不允许跨过变量的初始化语句直接跳转到变量作用域内的另一个位置</strong>.</p><div style="text-align:center;"> <img src="https://fzttypora.oss-cn-beijing.aliyuncs.com/typora_images/image-20240306113745854.png" alt="image-20240306113745854" /> </div><p>如果需要为某个 case 分支定义并初始化一个变量, 应该将变量 <strong>定义在块内</strong>, 从而确保后面所有的 case 标签都在变量作用域之外.</p><h2 id="5-4-迭代语句"><a href="#5-4-迭代语句" class="headerlink" title="5.4 迭代语句"></a>5.4 迭代语句</h2><h3 id="5-4-1-while-语句"><a href="#5-4-1-while-语句" class="headerlink" title="5.4.1 while 语句"></a>5.4.1 while 语句</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">while</span> (condition)<br>    statement;<br></code></pre></td></tr></table></figure><h3 id="5-4-2-do-while-语句"><a href="#5-4-2-do-while-语句" class="headerlink" title="5.4.2 do while 语句"></a>5.4.2 do while 语句</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">do</span>&#123;<br>    statement;<br>&#125;<span class="hljs-keyword">while</span> (condition)<br></code></pre></td></tr></table></figure><blockquote><p>[!Note]</p><p>while 与 do while 语句仅在执行顺序上有所区别. 另外, while 语句的 condition 中可以定义循环控制变量. 但是 do while 语句中的 condition 中就不适合定义循环控制变量.</p></blockquote><h3 id="5-4-3-for-语句"><a href="#5-4-3-for-语句" class="headerlink" title="5.4.3 for 语句"></a>5.4.3 for 语句</h3><h4 id="传统-for-语句"><a href="#传统-for-语句" class="headerlink" title="传统 for 语句"></a>传统 for 语句</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span> (init-statement; condition; expression)<br>    statement;<br></code></pre></td></tr></table></figure><p>其中, init-statement 可以定义多个对象, 但是只能有 <strong>一条</strong> 声明语句, 所以这多个对象的类型需要相同.同时, init-statement, condition, expression 语句可以省略, 但是 <strong>分号</strong> 不可省略.</p><h4 id="for-范围语句"><a href="#for-范围语句" class="headerlink" title="for 范围语句"></a>for 范围语句</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span> (declaration : expression)<br>    statement;<br></code></pre></td></tr></table></figure><p>express 的值必须是一个 <strong>序列</strong>, 可以是初始值列表, 数组, vector 对象, string 对象等, 这些类型共同特点是都能返回迭代器对象的 begin 和 end 成员.</p><p>declaration 定义一个变量, 序列中的每个元素都能转换成变量的类型. 可以使用 auto 类型说明符. 如果需要改变序列的元素, 需要将变量声明为 <strong>引用类型</strong>.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;r : v)&#123;<br>    r*=<span class="hljs-number">2</span>;<br>&#125;<br><span class="hljs-comment">// 等价于</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> beg = v.<span class="hljs-built_in">begin</span>(), end=v.<span class="hljs-built_in">end</span>(); beg!=end; ++beg)&#123;<br>    <span class="hljs-keyword">auto</span> &amp;r = *beg;<br>    r*=<span class="hljs-number">2</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>由于事先 <strong>预存了 end</strong> 的值, 在循环中增加或删除容器中元素可能会是预存的 end 函数值无效, 所以上述操作是非法的.</p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
      <category>C++ Primer 学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
